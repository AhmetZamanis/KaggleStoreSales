<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ahmet Zamanis">

<title>Time series regression - Store sales forecasting, Part 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="ReportPart1_files/libs/clipboard/clipboard.min.js"></script>
<script src="ReportPart1_files/libs/quarto-html/quarto.js"></script>
<script src="ReportPart1_files/libs/quarto-html/popper.min.js"></script>
<script src="ReportPart1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ReportPart1_files/libs/quarto-html/anchor.min.js"></script>
<link href="ReportPart1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ReportPart1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ReportPart1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ReportPart1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ReportPart1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data preparation</a></li>
  <li><a href="#overview-of-hybrid-modeling-approach" id="toc-overview-of-hybrid-modeling-approach" class="nav-link" data-scroll-target="#overview-of-hybrid-modeling-approach">Overview of hybrid modeling approach</a></li>
  <li><a href="#exploratory-analysis-1---time-calendar-effects" id="toc-exploratory-analysis-1---time-calendar-effects" class="nav-link" data-scroll-target="#exploratory-analysis-1---time-calendar-effects">Exploratory analysis 1 - Time &amp; calendar effects</a>
  <ul class="collapse">
  <li><a href="#trend" id="toc-trend" class="nav-link" data-scroll-target="#trend">Trend</a></li>
  <li><a href="#seasonality" id="toc-seasonality" class="nav-link" data-scroll-target="#seasonality">Seasonality</a></li>
  <li><a href="#autocorrelation-partial-autocorrelation" id="toc-autocorrelation-partial-autocorrelation" class="nav-link" data-scroll-target="#autocorrelation-partial-autocorrelation">Autocorrelation &amp; partial autocorrelation</a></li>
  <li><a href="#april-2016-earthquake" id="toc-april-2016-earthquake" class="nav-link" data-scroll-target="#april-2016-earthquake">April 2016 Earthquake</a></li>
  </ul></li>
  <li><a href="#feature-engineering-1---time-calendar-features" id="toc-feature-engineering-1---time-calendar-features" class="nav-link" data-scroll-target="#feature-engineering-1---time-calendar-features">Feature engineering 1 - Time &amp; calendar features</a>
  <ul class="collapse">
  <li><a href="#calendar-effects-weekly-seasonality-features" id="toc-calendar-effects-weekly-seasonality-features" class="nav-link" data-scroll-target="#calendar-effects-weekly-seasonality-features">Calendar effects &amp; weekly seasonality features</a></li>
  <li><a href="#trend-monthly-seasonality-features" id="toc-trend-monthly-seasonality-features" class="nav-link" data-scroll-target="#trend-monthly-seasonality-features">Trend &amp; monthly seasonality features</a></li>
  </ul></li>
  <li><a href="#model-1---time-effects-decomposition" id="toc-model-1---time-effects-decomposition" class="nav-link" data-scroll-target="#model-1---time-effects-decomposition">Model 1 - Time effects decomposition</a>
  <ul class="collapse">
  <li><a href="#preprocessing" id="toc-preprocessing" class="nav-link" data-scroll-target="#preprocessing">Preprocessing</a></li>
  <li><a href="#model-specification" id="toc-model-specification" class="nav-link" data-scroll-target="#model-specification">Model specification</a></li>
  <li><a href="#model-validation-predicting-2017-sales" id="toc-model-validation-predicting-2017-sales" class="nav-link" data-scroll-target="#model-validation-predicting-2017-sales">Model validation: Predicting 2017 sales</a></li>
  <li><a href="#rolling-crossvalidation" id="toc-rolling-crossvalidation" class="nav-link" data-scroll-target="#rolling-crossvalidation">Rolling crossvalidation</a></li>
  <li><a href="#residuals-diagnosis-stationarity" id="toc-residuals-diagnosis-stationarity" class="nav-link" data-scroll-target="#residuals-diagnosis-stationarity">Residuals diagnosis &amp; stationarity</a></li>
  <li><a href="#time-decomposition" id="toc-time-decomposition" class="nav-link" data-scroll-target="#time-decomposition">Time decomposition</a></li>
  </ul></li>
  <li><a href="#exploratory-analysis-2---lags-covariates" id="toc-exploratory-analysis-2---lags-covariates" class="nav-link" data-scroll-target="#exploratory-analysis-2---lags-covariates">Exploratory analysis 2 - Lags &amp; covariates</a>
  <ul class="collapse">
  <li><a href="#covariates-stationarity-differencing" id="toc-covariates-stationarity-differencing" class="nav-link" data-scroll-target="#covariates-stationarity-differencing">Covariates stationarity &amp; differencing</a></li>
  <li><a href="#sales-features" id="toc-sales-features" class="nav-link" data-scroll-target="#sales-features">Sales features</a></li>
  <li><a href="#oil-features" id="toc-oil-features" class="nav-link" data-scroll-target="#oil-features">Oil features</a></li>
  <li><a href="#onpromotion-features" id="toc-onpromotion-features" class="nav-link" data-scroll-target="#onpromotion-features">Onpromotion features</a></li>
  <li><a href="#transactions-features" id="toc-transactions-features" class="nav-link" data-scroll-target="#transactions-features">Transactions features</a></li>
  </ul></li>
  <li><a href="#model-2---lags-covariates" id="toc-model-2---lags-covariates" class="nav-link" data-scroll-target="#model-2---lags-covariates">Model 2 - Lags &amp; covariates</a>
  <ul class="collapse">
  <li><a href="#preprocessing-1" id="toc-preprocessing-1" class="nav-link" data-scroll-target="#preprocessing-1">Preprocessing</a></li>
  <li><a href="#model-specification-1" id="toc-model-specification-1" class="nav-link" data-scroll-target="#model-specification-1">Model specification</a></li>
  <li><a href="#model-validation-predicting-2017-sales-1" id="toc-model-validation-predicting-2017-sales-1" class="nav-link" data-scroll-target="#model-validation-predicting-2017-sales-1">Model validation: Predicting 2017 sales</a></li>
  <li><a href="#backtesting-historical-forecasts" id="toc-backtesting-historical-forecasts" class="nav-link" data-scroll-target="#backtesting-historical-forecasts">Backtesting / Historical forecasts</a></li>
  <li><a href="#residuals-diagnosis-stationarity-1" id="toc-residuals-diagnosis-stationarity-1" class="nav-link" data-scroll-target="#residuals-diagnosis-stationarity-1">Residuals diagnosis &amp; stationarity</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Time series regression - Store sales forecasting, Part 1</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ahmet Zamanis </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This is a report on time series analysis &amp; regression modeling, performed in Python, mainly with the <a href="https://unit8co.github.io/darts/">Darts</a> library. The dataset is from the <a href="https://www.kaggle.com/competitions/store-sales-time-series-forecasting">Kaggle Store Sales - Time Series Forecasting</a> competition. The data consists of daily sales data for an Ecuadorian supermarket chain between 2013 and 2017. This is Part 1 of the analysis, which will focus only on forecasting the daily national sales of the chain, across all stores and categories. In Part 2, we will forecast the sales in each category - store combination as required by the competition, and attempt various hierarchical reconciliation techniques.</p>
<p>The main information source used extensively for this analysis is the textbook <a href="https://otexts.com/fpp3/">Forecasting: Principles and Practice</a>, written by Rob J. Hyndman and George Athanasopoulos. The book is the most complete source on time series analysis &amp; forecasting I could find. It uses R and the <a href="https://tidyverts.org/">tidyverts</a> libraries in its example code.</p>
</section>
<section id="data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation">Data preparation</h2>
<p>The data is split into several .csv files. <strong>train.csv</strong> and <strong>test.csv</strong> are the main datasets, consisting of daily sales data. The training data ranges from 01-01-2013 to 15-08-2017, and the testing data consists of the following 15 days, in August 2017. We won’t do a competition submission in Part 1, so we won’t load the testing data.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># View the daily sales data</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>df_train.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>id</th>
      <th>date</th>
      <th>store_nbr</th>
      <th>family</th>
      <th>sales</th>
      <th>onpromotion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>2013-01-01</td>
      <td>1</td>
      <td>AUTOMOTIVE</td>
      <td>0.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2013-01-01</td>
      <td>1</td>
      <td>BABY CARE</td>
      <td>0.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>2013-01-01</td>
      <td>1</td>
      <td>BEAUTY</td>
      <td>0.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>2013-01-01</td>
      <td>1</td>
      <td>BEVERAGES</td>
      <td>0.0000</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>2013-01-01</td>
      <td>1</td>
      <td>BOOKS</td>
      <td>0.0000</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<ul>
<li><p>For each day, we have the sales in each store (out of a possible 54) and each product category (out of a possible 33). This amounts to 1782 time series that need to be forecasted for the competition, but in Part 1 of this analysis, we will keep it simple and only forecast the national sales in each day, in all categories.</p></li>
<li><p><strong>onpromotion</strong> is the number of items on sale that day, in that category &amp; store.</p></li>
</ul>
<p><strong>stores.csv</strong> contains more information about each store: The city, state, store type and store cluster.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>df_stores.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>store_nbr</th>
      <th>city</th>
      <th>state</th>
      <th>type</th>
      <th>cluster</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>9</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>Santo Domingo</td>
      <td>Santo Domingo de los Tsachilas</td>
      <td>D</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p><strong>holidays.csv</strong> contains information about local (city-wide), regional (state-wide) and national holidays, and some special nation-wide events in the time period. We will use these along with the stores’ location data to create calendar features.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df_holidays.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>type</th>
      <th>locale</th>
      <th>locale_name</th>
      <th>description</th>
      <th>transferred</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2012-03-02</td>
      <td>Holiday</td>
      <td>Local</td>
      <td>Manta</td>
      <td>Fundacion de Manta</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2012-04-01</td>
      <td>Holiday</td>
      <td>Regional</td>
      <td>Cotopaxi</td>
      <td>Provincializacion de Cotopaxi</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2012-04-12</td>
      <td>Holiday</td>
      <td>Local</td>
      <td>Cuenca</td>
      <td>Fundacion de Cuenca</td>
      <td>False</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2012-04-14</td>
      <td>Holiday</td>
      <td>Local</td>
      <td>Libertad</td>
      <td>Cantonizacion de Libertad</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2012-04-21</td>
      <td>Holiday</td>
      <td>Local</td>
      <td>Riobamba</td>
      <td>Cantonizacion de Riobamba</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p><strong>oil.csv</strong> consists of the daily oil prices in the time period. Ecuador has an oil-dependent economy, so this may be a useful predictor of the cyclicality in supermarket sales. We don’t have the oil price for the first day of the time series.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df_oil.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>dcoilwtico</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2013-01-01</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2013-01-02</td>
      <td>93.1400</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2013-01-03</td>
      <td>92.9700</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2013-01-04</td>
      <td>93.1200</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2013-01-07</td>
      <td>93.2000</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p><strong>transactions.csv</strong> consists of the daily number of transactions at a store. Another potentially useful feature. Each row is the number of transactions in all categories, one day, at one store.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df_trans.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>store_nbr</th>
      <th>transactions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2013-01-01</td>
      <td>25</td>
      <td>770</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2013-01-02</td>
      <td>1</td>
      <td>2111</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2013-01-02</td>
      <td>2</td>
      <td>2358</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2013-01-02</td>
      <td>3</td>
      <td>3487</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2013-01-02</td>
      <td>4</td>
      <td>1922</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>We will rename some columns from the datasets and merge the supplementary information into the sales dataset. We’ll aggregate daily transactions across all stores beforehand, as we are only interested in predicting daily national sales.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Rename columns</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df_holidays <span class="op">=</span> df_holidays.rename(columns <span class="op">=</span> {<span class="st">"type"</span>:<span class="st">"holiday_type"</span>})</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>df_oil <span class="op">=</span> df_oil.rename(columns <span class="op">=</span> {<span class="st">"dcoilwtico"</span>:<span class="st">"oil"</span>})</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>df_stores <span class="op">=</span> df_stores.rename(columns <span class="op">=</span> {</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"type"</span>:<span class="st">"store_type"</span>, <span class="st">"cluster"</span>:<span class="st">"store_cluster"</span>})</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggregate daily transactions across all stores</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>df_trans <span class="op">=</span> df_trans.groupby(<span class="st">"date"</span>).transactions.<span class="bu">sum</span>()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Add columns from oil, stores and transactions datasets into main data</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(df_trans, on <span class="op">=</span> [<span class="st">"date"</span>], how <span class="op">=</span> <span class="st">"left"</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(df_oil, on <span class="op">=</span> <span class="st">"date"</span>, how <span class="op">=</span> <span class="st">"left"</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(df_stores, on <span class="op">=</span> <span class="st">"store_nbr"</span>, how <span class="op">=</span> <span class="st">"left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Incorporating the holidays information into the sales dataset will require more work.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Split holidays data into local, regional, national and events</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>events <span class="op">=</span> df_holidays[df_holidays[<span class="st">"holiday_type"</span>] <span class="op">==</span> <span class="st">"Event"</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>df_holidays <span class="op">=</span> df_holidays.drop(labels<span class="op">=</span>(events.index), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>local <span class="op">=</span> df_holidays.loc[df_holidays[<span class="st">"locale"</span>] <span class="op">==</span> <span class="st">"Local"</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>regional <span class="op">=</span> df_holidays.loc[df_holidays[<span class="st">"locale"</span>] <span class="op">==</span> <span class="st">"Regional"</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>national <span class="op">=</span> df_holidays.loc[df_holidays[<span class="st">"locale"</span>] <span class="op">==</span> <span class="st">"National"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are cases of multiple holidays or events sharing the same date and locale. We’ll inspect the duplicates and drop them so we don’t have issues in feature engineering.</p>
<ul>
<li><p>Rows with <strong>transferred = True</strong> are dates that are normally holidays, but the holiday was transferred to another date. In other words, these are not holidays in effect.</p></li>
<li><p>Rows with <strong>holiday_type = Transfer</strong> are dates that are not normally holidays, but had another holiday transferred to this date. In other words, these are holidays in effect.</p></li>
<li><p>Rows with <strong>holiday_type = Bridge</strong> are dates that are not normally holidays, but were added to extend preceding / following holidays.</p></li>
</ul>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect local holidays sharing same date &amp; locale</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>local[local.duplicated([<span class="st">"date"</span>, <span class="st">"locale_name"</span>], keep <span class="op">=</span> <span class="va">False</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>holiday_type</th>
      <th>locale</th>
      <th>locale_name</th>
      <th>description</th>
      <th>transferred</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>264</th>
      <td>2016-07-24</td>
      <td>Additional</td>
      <td>Local</td>
      <td>Guayaquil</td>
      <td>Fundacion de Guayaquil-1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>265</th>
      <td>2016-07-24</td>
      <td>Transfer</td>
      <td>Local</td>
      <td>Guayaquil</td>
      <td>Traslado Fundacion de Guayaquil</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the transfer row</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>local <span class="op">=</span> local.drop(<span class="dv">265</span>, axis <span class="op">=</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect regional holidays sharing same date &amp; locale. None exist</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>regional[regional.duplicated([<span class="st">"date"</span>, <span class="st">"locale_name"</span>], keep <span class="op">=</span> <span class="va">False</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>holiday_type</th>
      <th>locale</th>
      <th>locale_name</th>
      <th>description</th>
      <th>transferred</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect national holidays sharing same date &amp; locale</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>national[national.duplicated([<span class="st">"date"</span>], keep <span class="op">=</span> <span class="va">False</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>holiday_type</th>
      <th>locale</th>
      <th>locale_name</th>
      <th>description</th>
      <th>transferred</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>35</th>
      <td>2012-12-24</td>
      <td>Bridge</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Puente Navidad</td>
      <td>False</td>
    </tr>
    <tr>
      <th>36</th>
      <td>2012-12-24</td>
      <td>Additional</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Navidad-1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>39</th>
      <td>2012-12-31</td>
      <td>Bridge</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Puente Primer dia del ano</td>
      <td>False</td>
    </tr>
    <tr>
      <th>40</th>
      <td>2012-12-31</td>
      <td>Additional</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Primer dia del ano-1</td>
      <td>False</td>
    </tr>
    <tr>
      <th>156</th>
      <td>2014-12-26</td>
      <td>Bridge</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Puente Navidad</td>
      <td>False</td>
    </tr>
    <tr>
      <th>157</th>
      <td>2014-12-26</td>
      <td>Additional</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Navidad+1</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop bridge days</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>national <span class="op">=</span> national.drop([<span class="dv">35</span>, <span class="dv">39</span>, <span class="dv">156</span>], axis <span class="op">=</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect events sharing same date</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>events[events.duplicated([<span class="st">"date"</span>], keep <span class="op">=</span> <span class="va">False</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>date</th>
      <th>holiday_type</th>
      <th>locale</th>
      <th>locale_name</th>
      <th>description</th>
      <th>transferred</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>244</th>
      <td>2016-05-08</td>
      <td>Event</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Terremoto Manabi+22</td>
      <td>False</td>
    </tr>
    <tr>
      <th>245</th>
      <td>2016-05-08</td>
      <td>Event</td>
      <td>National</td>
      <td>Ecuador</td>
      <td>Dia de la Madre</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the earthquake row as it is a one-time event</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>events <span class="op">=</span> events.drop(<span class="dv">244</span>, axis <span class="op">=</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>After getting rid of duplicates, we can create binary columns that signify whether a date was a local / regional / national holiday / event. We’ll merge these back into the sales data.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add local_holiday binary column to local holidays data, to be merged into main </span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># data.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>local[<span class="st">"local_holiday"</span>] <span class="op">=</span> (</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  local.holiday_type.isin([<span class="st">"Transfer"</span>, <span class="st">"Additional"</span>, <span class="st">"Bridge"</span>]) <span class="op">|</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  ((local.holiday_type <span class="op">==</span> <span class="st">"Holiday"</span>) <span class="op">&amp;</span> (local.transferred <span class="op">==</span> <span class="va">False</span>))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  ).astype(<span class="bu">int</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Add regional_holiday binary column to regional holidays data</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>regional[<span class="st">"regional_holiday"</span>] <span class="op">=</span> (</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  regional.holiday_type.isin([<span class="st">"Transfer"</span>, <span class="st">"Additional"</span>, <span class="st">"Bridge"</span>]) <span class="op">|</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  ((regional.holiday_type <span class="op">==</span> <span class="st">"Holiday"</span>) <span class="op">&amp;</span> (regional.transferred <span class="op">==</span> <span class="va">False</span>))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  ).astype(<span class="bu">int</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Add national_holiday binary column to national holidays data</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>national[<span class="st">"national_holiday"</span>] <span class="op">=</span> (</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  national.holiday_type.isin([<span class="st">"Transfer"</span>, <span class="st">"Additional"</span>, <span class="st">"Bridge"</span>]) <span class="op">|</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  ((national.holiday_type <span class="op">==</span> <span class="st">"Holiday"</span>) <span class="op">&amp;</span> (national.transferred <span class="op">==</span> <span class="va">False</span>))</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  ).astype(<span class="bu">int</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add event column to events</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>events[<span class="st">"event"</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge local holidays binary column to main data, on date and city</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>local_merge <span class="op">=</span> local.drop(</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> [</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">"holiday_type"</span>, <span class="st">"locale"</span>, <span class="st">"description"</span>, <span class="st">"transferred"</span>], axis <span class="op">=</span> <span class="dv">1</span>).rename(</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>      columns <span class="op">=</span> {<span class="st">"locale_name"</span>:<span class="st">"city"</span>})</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(local_merge, how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span>[<span class="st">"date"</span>, <span class="st">"city"</span>])</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"local_holiday"</span>] <span class="op">=</span> df_train[<span class="st">"local_holiday"</span>].fillna(<span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge regional holidays binary column to main data</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>regional_merge <span class="op">=</span> regional.drop(</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> [</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">"holiday_type"</span>, <span class="st">"locale"</span>, <span class="st">"description"</span>, <span class="st">"transferred"</span>], axis <span class="op">=</span> <span class="dv">1</span>).rename(</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>      columns <span class="op">=</span> {<span class="st">"locale_name"</span>:<span class="st">"state"</span>})</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(regional_merge, how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span>[<span class="st">"date"</span>, <span class="st">"state"</span>])</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"regional_holiday"</span>] <span class="op">=</span> df_train[<span class="st">"regional_holiday"</span>].fillna(<span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge national holidays binary column to main data, on date</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>national_merge <span class="op">=</span> national.drop(</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> [</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">"holiday_type"</span>, <span class="st">"locale"</span>, <span class="st">"locale_name"</span>, <span class="st">"description"</span>, </span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    <span class="st">"transferred"</span>], axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(national_merge, how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"national_holiday"</span>] <span class="op">=</span> df_train[<span class="st">"national_holiday"</span>].fillna(<span class="dv">0</span>).astype(<span class="bu">int</span>)</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge events binary column to main data</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>events_merge <span class="op">=</span> events.drop(</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>  labels <span class="op">=</span> [</span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>    <span class="st">"holiday_type"</span>, <span class="st">"locale"</span>, <span class="st">"locale_name"</span>, <span class="st">"description"</span>, </span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>    <span class="st">"transferred"</span>], axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.merge(events_merge, how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"event"</span>] <span class="op">=</span> df_train[<span class="st">"event"</span>].fillna(<span class="dv">0</span>).astype(<span class="bu">int</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ll set the <strong>date</strong> column to a DateTimeIndex, and view the sales data with the added columns.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set datetime index</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.set_index(pd.to_datetime(df_train.date))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.drop(<span class="st">"date"</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>df_train.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>id</th>
      <th>store_nbr</th>
      <th>family</th>
      <th>sales</th>
      <th>onpromotion</th>
      <th>transactions</th>
      <th>oil</th>
      <th>city</th>
      <th>state</th>
      <th>store_type</th>
      <th>store_cluster</th>
      <th>local_holiday</th>
      <th>regional_holiday</th>
      <th>national_holiday</th>
      <th>event</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0</td>
      <td>1</td>
      <td>AUTOMOTIVE</td>
      <td>0.0000</td>
      <td>0</td>
      <td>770.0000</td>
      <td>NaN</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2013-01-01</th>
      <td>1</td>
      <td>1</td>
      <td>BABY CARE</td>
      <td>0.0000</td>
      <td>0</td>
      <td>770.0000</td>
      <td>NaN</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2013-01-01</th>
      <td>2</td>
      <td>1</td>
      <td>BEAUTY</td>
      <td>0.0000</td>
      <td>0</td>
      <td>770.0000</td>
      <td>NaN</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2013-01-01</th>
      <td>3</td>
      <td>1</td>
      <td>BEVERAGES</td>
      <td>0.0000</td>
      <td>0</td>
      <td>770.0000</td>
      <td>NaN</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2013-01-01</th>
      <td>4</td>
      <td>1</td>
      <td>BOOKS</td>
      <td>0.0000</td>
      <td>0</td>
      <td>770.0000</td>
      <td>NaN</td>
      <td>Quito</td>
      <td>Pichincha</td>
      <td>D</td>
      <td>13</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>With financial data, it’s a good idea to normalize for inflation. We’ll CPI adjust the sales and oil prices columns, with 2010 as our base year. The CPI values for Ecuador in the time period were retrieved <a href="https://data.worldbank.org/indicator/FP.CPI.TOTL?end=2017&amp;locations=EC&amp;start=2010&amp;view=chart">here</a>.</p>
<ul>
<li><p>We’ll use the yearly CPI values for simplicity’s sake, but it’s possible to use monthly CPI for more accuracy.</p></li>
<li><p>Since 2017 is not complete in the data, and we’ll use it as the validation period, we’ll use 2016’s CPI for 2017 to avoid leaking information from the future into our predictions.</p></li>
</ul>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># CPI adjust sales and oil, with CPI 2010 = 100</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>cpis <span class="op">=</span> {</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"2010"</span>:<span class="dv">100</span>, <span class="st">"2013"</span>:<span class="fl">112.8</span>, <span class="st">"2014"</span>:<span class="fl">116.8</span>, <span class="st">"2015"</span>:<span class="fl">121.5</span>, <span class="st">"2016"</span>:<span class="fl">123.6</span>, </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"2017"</span>:<span class="fl">123.6</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> [<span class="dv">2013</span>, <span class="dv">2014</span>, <span class="dv">2015</span>, <span class="dv">2016</span>, <span class="dv">2017</span>]:</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  df_train[<span class="st">"sales"</span>].loc[df_train.index.year<span class="op">==</span>year] <span class="op">=</span> df_train[<span class="st">"sales"</span>].loc[</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    df_train.index.year<span class="op">==</span>year] <span class="op">/</span> cpis[<span class="bu">str</span>(year)] <span class="op">*</span> cpis[<span class="st">"2010"</span>]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  df_train[<span class="st">"oil"</span>].loc[df_train.index.year<span class="op">==</span>year] <span class="op">=</span> df_train[<span class="st">"oil"</span>].loc[</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    df_train.index.year<span class="op">==</span>year] <span class="op">/</span> cpis[<span class="bu">str</span>(year)] <span class="op">*</span> cpis[<span class="st">"2010"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have some rows with missing values in our training data.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check missing values in each column</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>pd.isnull(df_train).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>id                       0
store_nbr                0
family                   0
sales                    0
onpromotion              0
transactions          3564
oil                 928422
city                     0
state                    0
store_type               0
store_cluster            0
local_holiday            0
regional_holiday         0
national_holiday         0
event                    0
dtype: int64</code></pre>
</div>
</div>
<p>We will interpolate the missing values in the oil and transactions columns using time interpolation. This performs linear interpolation, but also takes the date-time index of observations into account.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"oil"</span>] <span class="op">=</span> df_train[<span class="st">"oil"</span>].interpolate(<span class="st">"time"</span>, limit_direction <span class="op">=</span> <span class="st">"both"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"transactions"</span>] <span class="op">=</span> df_train[<span class="st">"transactions"</span>].interpolate(</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"time"</span>, limit_direction <span class="op">=</span> <span class="st">"both"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will now aggregate daily sales across all categories and stores, to retrieve our target variable. We have 1684 days of national sales data.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>sales <span class="op">=</span> df_train.groupby(<span class="st">"date"</span>).sales.<span class="bu">sum</span>()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>sales</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>date
2013-01-01     2226.6126
2013-01-02   439798.2429
2013-01-03   320444.3538
2013-01-04   314237.3024
2013-01-05   423182.7316
                 ...    
2017-08-11   668587.1537
2017-08-12   641286.8407
2017-08-13   700355.7261
2017-08-14   615633.0146
2017-08-15   617040.4012
Name: sales, Length: 1684, dtype: float64</code></pre>
</div>
</div>
<p>We will create a Darts <a href="https://unit8co.github.io/darts/generated_api/darts.timeseries.html">TimeSeries</a> with our target variable.</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts <span class="im">import</span> TimeSeries</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>ts_sales <span class="op">=</span> TimeSeries.from_series(</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  sales, </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  freq<span class="op">=</span><span class="st">"D"</span> <span class="co"># Time series frequency is daily</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>ts_sales</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">

<div><svg style="position: absolute; width: 0; height: 0; overflow: hidden">
<defs>
<symbol id="icon-database" viewbox="0 0 32 32">
<path d="M16 0c-8.837 0-16 2.239-16 5v4c0 2.761 7.163 5 16 5s16-2.239 16-5v-4c0-2.761-7.163-5-16-5z"></path>
<path d="M16 17c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
<path d="M16 26c-8.837 0-16-2.239-16-5v6c0 2.761 7.163 5 16 5s16-2.239 16-5v-6c0 2.761-7.163 5-16 5z"></path>
</symbol>
<symbol id="icon-file-text2" viewbox="0 0 32 32">
<path d="M28.681 7.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-15.5c-1.378 0-2.5 1.121-2.5 2.5v27c0 1.378 1.122 2.5 2.5 2.5h23c1.378 0 2.5-1.122 2.5-2.5v-19.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 5.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-23c-0.271 0-0.5-0.229-0.5-0.5v-27c0-0.271 0.229-0.5 0.5-0.5 0 0 15.499-0 15.5 0v7c0 0.552 0.448 1 1 1h7v19.5z"></path>
<path d="M23 26h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 22h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
<path d="M23 18h-14c-0.552 0-1-0.448-1-1s0.448-1 1-1h14c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path>
</symbol>
</defs>
</svg>
<style>/* CSS stylesheet for displaying xarray objects in jupyterlab.
 *
 */

:root {
  --xr-font-color0: var(--jp-content-font-color0, rgba(0, 0, 0, 1));
  --xr-font-color2: var(--jp-content-font-color2, rgba(0, 0, 0, 0.54));
  --xr-font-color3: var(--jp-content-font-color3, rgba(0, 0, 0, 0.38));
  --xr-border-color: var(--jp-border-color2, #e0e0e0);
  --xr-disabled-color: var(--jp-layout-color3, #bdbdbd);
  --xr-background-color: var(--jp-layout-color0, white);
  --xr-background-color-row-even: var(--jp-layout-color1, white);
  --xr-background-color-row-odd: var(--jp-layout-color2, #eeeeee);
}

html[theme=dark],
body[data-theme=dark],
body.vscode-dark {
  --xr-font-color0: rgba(255, 255, 255, 1);
  --xr-font-color2: rgba(255, 255, 255, 0.54);
  --xr-font-color3: rgba(255, 255, 255, 0.38);
  --xr-border-color: #1F1F1F;
  --xr-disabled-color: #515151;
  --xr-background-color: #111111;
  --xr-background-color-row-even: #111111;
  --xr-background-color-row-odd: #313131;
}

.xr-wrap {
  display: block !important;
  min-width: 300px;
  max-width: 700px;
}

.xr-text-repr-fallback {
  /* fallback to plain text repr when CSS is not injected (untrusted notebook) */
  display: none;
}

.xr-header {
  padding-top: 6px;
  padding-bottom: 6px;
  margin-bottom: 4px;
  border-bottom: solid 1px var(--xr-border-color);
}

.xr-header > div,
.xr-header > ul {
  display: inline;
  margin-top: 0;
  margin-bottom: 0;
}

.xr-obj-type,
.xr-array-name {
  margin-left: 2px;
  margin-right: 10px;
}

.xr-obj-type {
  color: var(--xr-font-color2);
}

.xr-sections {
  padding-left: 0 !important;
  display: grid;
  grid-template-columns: 150px auto auto 1fr 20px 20px;
}

.xr-section-item {
  display: contents;
}

.xr-section-item input {
  display: none;
}

.xr-section-item input + label {
  color: var(--xr-disabled-color);
}

.xr-section-item input:enabled + label {
  cursor: pointer;
  color: var(--xr-font-color2);
}

.xr-section-item input:enabled + label:hover {
  color: var(--xr-font-color0);
}

.xr-section-summary {
  grid-column: 1;
  color: var(--xr-font-color2);
  font-weight: 500;
}

.xr-section-summary > span {
  display: inline-block;
  padding-left: 0.5em;
}

.xr-section-summary-in:disabled + label {
  color: var(--xr-font-color2);
}

.xr-section-summary-in + label:before {
  display: inline-block;
  content: '►';
  font-size: 11px;
  width: 15px;
  text-align: center;
}

.xr-section-summary-in:disabled + label:before {
  color: var(--xr-disabled-color);
}

.xr-section-summary-in:checked + label:before {
  content: '▼';
}

.xr-section-summary-in:checked + label > span {
  display: none;
}

.xr-section-summary,
.xr-section-inline-details {
  padding-top: 4px;
  padding-bottom: 4px;
}

.xr-section-inline-details {
  grid-column: 2 / -1;
}

.xr-section-details {
  display: none;
  grid-column: 1 / -1;
  margin-bottom: 5px;
}

.xr-section-summary-in:checked ~ .xr-section-details {
  display: contents;
}

.xr-array-wrap {
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: 20px auto;
}

.xr-array-wrap > label {
  grid-column: 1;
  vertical-align: top;
}

.xr-preview {
  color: var(--xr-font-color3);
}

.xr-array-preview,
.xr-array-data {
  padding: 0 5px !important;
  grid-column: 2;
}

.xr-array-data,
.xr-array-in:checked ~ .xr-array-preview {
  display: none;
}

.xr-array-in:checked ~ .xr-array-data,
.xr-array-preview {
  display: inline-block;
}

.xr-dim-list {
  display: inline-block !important;
  list-style: none;
  padding: 0 !important;
  margin: 0;
}

.xr-dim-list li {
  display: inline-block;
  padding: 0;
  margin: 0;
}

.xr-dim-list:before {
  content: '(';
}

.xr-dim-list:after {
  content: ')';
}

.xr-dim-list li:not(:last-child):after {
  content: ',';
  padding-right: 5px;
}

.xr-has-index {
  font-weight: bold;
}

.xr-var-list,
.xr-var-item {
  display: contents;
}

.xr-var-item > div,
.xr-var-item label,
.xr-var-item > .xr-var-name span {
  background-color: var(--xr-background-color-row-even);
  margin-bottom: 0;
}

.xr-var-item > .xr-var-name:hover span {
  padding-right: 5px;
}

.xr-var-list > li:nth-child(odd) > div,
.xr-var-list > li:nth-child(odd) > label,
.xr-var-list > li:nth-child(odd) > .xr-var-name span {
  background-color: var(--xr-background-color-row-odd);
}

.xr-var-name {
  grid-column: 1;
}

.xr-var-dims {
  grid-column: 2;
}

.xr-var-dtype {
  grid-column: 3;
  text-align: right;
  color: var(--xr-font-color2);
}

.xr-var-preview {
  grid-column: 4;
}

.xr-index-preview {
  grid-column: 2 / 5;
  color: var(--xr-font-color2);
}

.xr-var-name,
.xr-var-dims,
.xr-var-dtype,
.xr-preview,
.xr-attrs dt {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 10px;
}

.xr-var-name:hover,
.xr-var-dims:hover,
.xr-var-dtype:hover,
.xr-attrs dt:hover {
  overflow: visible;
  width: auto;
  z-index: 1;
}

.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  display: none;
  background-color: var(--xr-background-color) !important;
  padding-bottom: 5px !important;
}

.xr-var-attrs-in:checked ~ .xr-var-attrs,
.xr-var-data-in:checked ~ .xr-var-data,
.xr-index-data-in:checked ~ .xr-index-data {
  display: block;
}

.xr-var-data > table {
  float: right;
}

.xr-var-name span,
.xr-var-data,
.xr-index-name div,
.xr-index-data,
.xr-attrs {
  padding-left: 25px !important;
}

.xr-attrs,
.xr-var-attrs,
.xr-var-data,
.xr-index-data {
  grid-column: 1 / -1;
}

dl.xr-attrs {
  padding: 0;
  margin: 0;
  display: grid;
  grid-template-columns: 125px auto;
}

.xr-attrs dt,
.xr-attrs dd {
  padding: 0;
  margin: 0;
  float: left;
  padding-right: 10px;
  width: auto;
}

.xr-attrs dt {
  font-weight: normal;
  grid-column: 1;
}

.xr-attrs dt:hover span {
  display: inline-block;
  background: var(--xr-background-color);
  padding-right: 10px;
}

.xr-attrs dd {
  grid-column: 2;
  white-space: pre-wrap;
  word-break: break-all;
}

.xr-icon-database,
.xr-icon-file-text2,
.xr-no-icon {
  display: inline-block;
  vertical-align: middle;
  width: 1em;
  height: 1.5em !important;
  stroke-width: 0;
  stroke: currentColor;
  fill: currentColor;
}
</style><pre class="xr-text-repr-fallback">&lt;TimeSeries (DataArray) (date: 1688, component: 1, sample: 1)&gt;
array([[[  2226.6126]],

       [[439798.2429]],

       [[320444.3538]],

       ...,

       [[700355.7261]],

       [[615633.0146]],

       [[617040.4012]]])
Coordinates:
  * date       (date) datetime64[ns] 2013-01-01 2013-01-02 ... 2017-08-15
  * component  (component) object 'sales'
Dimensions without coordinates: sample
Attributes:
    static_covariates:  None
    hierarchy:          None</pre><div class="xr-wrap" style="display:none"><div class="xr-header"><div class="xr-obj-type">TimeSeries (DataArray)</div><div class="xr-array-name"></div><ul class="xr-dim-list"><li><span class="xr-has-index">date</span>: 1688</li><li><span class="xr-has-index">component</span>: 1</li><li><span>sample</span>: 1</li></ul></div><ul class="xr-sections"><li class="xr-section-item"><div class="xr-array-wrap"><input id="section-b406b844-85ac-4cba-a54f-1c67b4e8a35b" class="xr-array-in" type="checkbox" checked=""><label for="section-b406b844-85ac-4cba-a54f-1c67b4e8a35b" title="Show/hide data repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-array-preview xr-preview"><span>2.227e+03 4.398e+05 3.204e+05 ... 7.004e+05 6.156e+05 6.17e+05</span></div><div class="xr-array-data"><pre>array([[[  2226.6126]],

       [[439798.2429]],

       [[320444.3538]],

       ...,

       [[700355.7261]],

       [[615633.0146]],

       [[617040.4012]]])</pre></div></div></li><li class="xr-section-item"><input id="section-8873c30c-0763-4350-a38c-b6ed251f956d" class="xr-section-summary-in" type="checkbox" checked=""><label for="section-8873c30c-0763-4350-a38c-b6ed251f956d" class="xr-section-summary">Coordinates: <span>(2)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><ul class="xr-var-list"><li class="xr-var-item"><div class="xr-var-name"><span class="xr-has-index">date</span></div><div class="xr-var-dims">(date)</div><div class="xr-var-dtype">datetime64[ns]</div><div class="xr-var-preview xr-preview">2013-01-01 ... 2017-08-15</div><input id="attrs-6c3739a6-2276-4bc2-9e01-5cafb850d77c" class="xr-var-attrs-in" type="checkbox" disabled=""><label for="attrs-6c3739a6-2276-4bc2-9e01-5cafb850d77c" title="Show/Hide attributes"><svg class="icon xr-icon-file-text2"><use href="#icon-file-text2"></use></svg></label><input id="data-a26a3abb-7161-45b4-91e9-76513ecb0318" class="xr-var-data-in" type="checkbox"><label for="data-a26a3abb-7161-45b4-91e9-76513ecb0318" title="Show/Hide data repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-var-attrs"><dl class="xr-attrs"></dl></div><div class="xr-var-data"><pre>array(['2013-01-01T00:00:00.000000000', '2013-01-02T00:00:00.000000000',
       '2013-01-03T00:00:00.000000000', ..., '2017-08-13T00:00:00.000000000',
       '2017-08-14T00:00:00.000000000', '2017-08-15T00:00:00.000000000'],
      dtype='datetime64[ns]')</pre></div></li><li class="xr-var-item"><div class="xr-var-name"><span class="xr-has-index">component</span></div><div class="xr-var-dims">(component)</div><div class="xr-var-dtype">object</div><div class="xr-var-preview xr-preview">'sales'</div><input id="attrs-fa0f7034-c46b-49e0-9912-3cc6060bc2e7" class="xr-var-attrs-in" type="checkbox" disabled=""><label for="attrs-fa0f7034-c46b-49e0-9912-3cc6060bc2e7" title="Show/Hide attributes"><svg class="icon xr-icon-file-text2"><use href="#icon-file-text2"></use></svg></label><input id="data-1f1d7d49-180e-4c8a-8875-2e84a75efdb8" class="xr-var-data-in" type="checkbox"><label for="data-1f1d7d49-180e-4c8a-8875-2e84a75efdb8" title="Show/Hide data repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-var-attrs"><dl class="xr-attrs"></dl></div><div class="xr-var-data"><pre>array(['sales'], dtype=object)</pre></div></li></ul></div></li><li class="xr-section-item"><input id="section-9736a6bf-ba86-43ed-9f47-8c12b8b66ca8" class="xr-section-summary-in" type="checkbox"><label for="section-9736a6bf-ba86-43ed-9f47-8c12b8b66ca8" class="xr-section-summary">Indexes: <span>(2)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><ul class="xr-var-list"><li class="xr-var-item"><div class="xr-index-name"><div>date</div></div><div class="xr-index-preview">PandasIndex</div><div></div><input id="index-e99a4bd2-696c-471e-a830-2b09f8bdafc4" class="xr-index-data-in" type="checkbox"><label for="index-e99a4bd2-696c-471e-a830-2b09f8bdafc4" title="Show/Hide index repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-index-data"><pre>PandasIndex(DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06', '2013-01-07', '2013-01-08',
               '2013-01-09', '2013-01-10',
               ...
               '2017-08-06', '2017-08-07', '2017-08-08', '2017-08-09',
               '2017-08-10', '2017-08-11', '2017-08-12', '2017-08-13',
               '2017-08-14', '2017-08-15'],
              dtype='datetime64[ns]', name='date', length=1688, freq='D'))</pre></div></li><li class="xr-var-item"><div class="xr-index-name"><div>component</div></div><div class="xr-index-preview">PandasIndex</div><div></div><input id="index-0f5a6cf6-fabc-4eb7-b95e-24acd43be2ea" class="xr-index-data-in" type="checkbox"><label for="index-0f5a6cf6-fabc-4eb7-b95e-24acd43be2ea" title="Show/Hide index repr"><svg class="icon xr-icon-database"><use href="#icon-database"></use></svg></label><div class="xr-index-data"><pre>PandasIndex(Index(['sales'], dtype='object', name='component'))</pre></div></li></ul></div></li><li class="xr-section-item"><input id="section-6f16c6b3-8e4a-4af4-a0a0-e48cc1e64116" class="xr-section-summary-in" type="checkbox" checked=""><label for="section-6f16c6b3-8e4a-4af4-a0a0-e48cc1e64116" class="xr-section-summary">Attributes: <span>(2)</span></label><div class="xr-section-inline-details"></div><div class="xr-section-details"><dl class="xr-attrs"><dt><span>static_covariates :</span></dt><dd>None</dd><dt><span>hierarchy :</span></dt><dd>None</dd></dl></div></li></ul></div></div>
</div>
</div>
<ul>
<li><p>Each Pandas series / dataframe column passed is stored as a component in the Darts TS. The date-time index is stored in <strong>time_index.</strong> We had 1684 rows in our Pandas series, but the Darts TS has 1688 dates. This means our series had some missing dates, which Darts completed automatically. We’ll fill in the values for these dates later.</p></li>
<li><p>To create a multivariate time series, we create a Pandas dataframe with each time series as a column, and a common date-time index. When we pass this dataframe to TimeSeries, we’ll have each time series as a component. If the time series have a <strong>hierarchy</strong>, i.e.&nbsp;if they sum up together in a certain way, we can map that hierarchy as a dictionary to later perform hierarchical reconciliation. We will explore this further in Part 2 of the analysis.</p></li>
<li><p>Static covariates are time-invariant covariates that may be used in predictions. In our case, the city or cluster of a store may be static covariates, but for part 1 of our analysis we are looking at national sales, so we won’t use these.</p></li>
</ul>
</section>
<section id="overview-of-hybrid-modeling-approach" class="level2">
<h2 class="anchored" data-anchor-id="overview-of-hybrid-modeling-approach">Overview of hybrid modeling approach</h2>
<p>A time series can be written as the sum of several components:</p>
<ul>
<li><p><strong>Trend:</strong> The long-term change.</p></li>
<li><p><strong>Seasonality:</strong> A fluctuation (or several) that repeats based on a fixed, known time period. For example, the fluctuation of retail store sales across days of a week, or hours of a day.</p></li>
<li><p><strong>Cyclicality:</strong> A fluctuation that does not repeat on a fixed, known time period. For example, the effect of a sharp increase / decrese in oil prices on car sales.</p></li>
<li><p><strong>Remainder / Error:</strong> The unpredictable component of the time series, at least with the available data and methods.</p></li>
</ul>
<p>When analyzing a time series with plots, it can be difficult to determine the nature and causes of fluctuations. It can be especially tricky to tell apart the cyclical effects from repeating seasonality. Because of this, we will split our analysis and modeling into two steps:</p>
<ul>
<li><p>In step 1, we will analyze the time effects: The trend, seasonality and calendar effects (such as holidays &amp; events). We’ll build a model that predicts these effects and remove the predictions from the time series, leaving the effects of cyclicality and the unpredictable component. This is called <strong>time decomposition.</strong></p></li>
<li><p>In step 2, we will re-analyze the decomposed time series, this time considering the effects of covariates and lagged values of sales itself as predictors, to try and account for the cyclicality. We’ll build a model that uses these predictors, train it on the decomposed sales, and add up the predictions of both models to arrive at our final predictions. This approach is called a <strong>hybrid model.</strong></p></li>
</ul>
</section>
<section id="exploratory-analysis-1---time-calendar-effects" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-analysis-1---time-calendar-effects">Exploratory analysis 1 - Time &amp; calendar effects</h2>
<section id="trend" class="level3">
<h3 class="anchored" data-anchor-id="trend">Trend</h3>
<p>Let’s start by analyzing the overall trend in sales. Darts offers the ability to plot time series quickly.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span>  ts_sales.plot()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span>  plt.ylabel(<span class="st">"Daily sales, millions"</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-25-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The time series plot shows us several things:</p>
<ul>
<li><p>Supermarket sales show an increasing trend over the years. The trend is close to linear overall, but the rate of increase declines roughly from the start of 2015.</p></li>
<li><p>Sales mostly fluctuate around a certain range, which suggests strong seasonality. However, there are also sharp deviations in certain periods, mainly across 2014 and at the start of 2015. This is likely cyclical in nature.</p></li>
<li><p>The “waves” of seasonal fluctuations seem to be getting bigger over time. This suggests we should use a multiplicative time decomposition instead of additive.</p></li>
<li><p>Sales decline very sharply in the first day of every year, likely because it’s a holiday.</p></li>
</ul>
</section>
<section id="seasonality" class="level3">
<h3 class="anchored" data-anchor-id="seasonality">Seasonality</h3>
<section id="annual-seasonality" class="level4">
<h4 class="anchored" data-anchor-id="annual-seasonality">Annual seasonality</h4>
<p>Let’s look at annual seasonality: How sales fluctuate over a year based on quarters, months, weeks of a year and days of a year. In the plots below, we have the daily sales averaged by each respective calendar period, colored by each year in the data. The confidence bands indicate the minimum and maximum daily sales in each respective period (in the last plot, we just have the daily sales without any averaging).</p>
<div class="cell" data-execution_count="25">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-26-output-1.png" class="img-fluid"></p>
</div>
</div>
<ul>
<li><p><strong>Quarterly:</strong> Sales do not seem to have a considerable quarterly seasonality pattern. However, the plot still shows us a few things:</p>
<ul>
<li><p>Sales generally slightly increase over a year.</p></li>
<li><p>In Q2 2014, there was a considerable drop. Sales declined almost to the level of Q2 2013. This was likely a cyclical effect.</p></li>
</ul></li>
<li><p><strong>Monthly:</strong> Sales do seem to fluctuate slightly over months, but there’s no clear seasonal pattern that’s apparent across all years. However, sales seem to sharply increase in November and December every year, likely due to Christmas.</p>
<ul>
<li><p>The cyclicality in 2014 is seen in more detail: Sales dropped almost to their 2013 levels in certain months, and recovered sharply in others.</p></li>
<li><p>We also see a considerable drop in the first half of 2015, where sales dropped roughly to 2014 levels, followed by a recovery.</p></li>
<li><p>There is a very sharp increase in April 2016, where sales were even higher than 2017 levels. This is due to a large earthquake that happened in April 16, 2016, and the related relief efforts.</p></li>
</ul></li>
<li><p><strong>Weekly:</strong> The seasonal patterns are more visible in the weekly plot, as we see the “waves” of fluctuation line up across years. It’s very likely the data has strong weekly seasonality, which is what we’d expect from supermarket sales.</p>
<ul>
<li><p>The data for 2017 ends after August 15, so the sharp decline afterwards is misleading.</p></li>
<li><p>The sharp decline at the end of 2016 is also misleading, as 2016 was a 366-day year.</p></li>
</ul></li>
<li><p><strong>Daily:</strong> This plot is a bit noisy, but the very similar fluctuations across all years indicate the data is strongly seasonal. It also highlights some cyclical effects such as the April 2016 earthquake and the 2014 drops.</p></li>
</ul>
<p>Another way to look at annual seasonality is to average sales in a certain calendar period across all years, without grouping by year.</p>
<div class="cell" data-execution_count="26">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-27-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This shows us the “overall” seasonality pattern across one year: We likely have strong weekly seasonality that persists over years, and some monthly seasonality especially towards December.</p>
</section>
<section id="monthly-weekly-seasonality" class="level4">
<h4 class="anchored" data-anchor-id="monthly-weekly-seasonality">Monthly &amp; weekly seasonality</h4>
<p>Now let’s look at seasonality across days of a month and days of a week. These will likely be the most important seasonality patterns in supermarket sales. There are three ways to look at these plots: First we will group them by year.</p>
<div class="cell" data-execution_count="27">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-28-output-1.png" class="img-fluid"></p>
</div>
</div>
<ul>
<li><p>The weekly seasonality pattern across days of a week is clear. Sales are lowest in Tuesdays, increase and peak at Sundays, then drop on Mondays. The pattern holds in all years.</p></li>
<li><p>The monthly seasonality across days of a month aren’t as strong, but look considerable. Sales are generally highest at the start of a month, likely because most salaries are paid at the end of a month, though the competition information also says salaries are paid biweekly, in the middle and at the end of each month.</p></li>
</ul>
<p>We can look at the same plots grouped by month.</p>
<div class="cell" data-execution_count="28">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-29-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This plot shows us the monthly and weekly seasonality pattern generally holds across all months, but December is a notable exception:</p>
<ul>
<li><p>Sales in December are considerably higher roughly after the 13th, due to Christmas. The Christmas peak seems to happen in the 23th, followed by a decline, and another sharp increase in the 30th.</p></li>
<li><p>The sales by day of week are also higher in December for every day, but the pattern of the weekly seasonality is the same.</p></li>
<li><p>We can also see that sales decline very sharply in January 1st, almost to zero, and make a considerably sharp recovery in the 2nd.</p></li>
</ul>
<p>And finally, without any grouping: The averages across all years.</p>
<div class="cell" data-execution_count="29">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-30-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This plot allows us to see the overall monthly seasonality pattern more clearly: Sales are higher at the start of a month, slightly decline until the mid-month payday, slightly increase afterwards, and start peaking again after the end-of-month payday.</p>
</section>
</section>
<section id="autocorrelation-partial-autocorrelation" class="level3">
<h3 class="anchored" data-anchor-id="autocorrelation-partial-autocorrelation">Autocorrelation &amp; partial autocorrelation</h3>
<p>Autocorrelation is the correlation of a variable at time T, with its own lagged values at time T-1, T-2 and so on. Partial autocorrelation can be thought of as the marginal contribution of each lagged value to autocorrelation, since the lags are likely to hold common information. The patterns in the autocorrelation and partial autocorrelation plots can give us insight into the seasonal patterns.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FIG3: ACF and PACF plots</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.graphics.tsaplots <span class="im">import</span> plot_acf, plot_pacf</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>fig3, axes3 <span class="op">=</span> plt.subplots(<span class="dv">2</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> fig3.suptitle(<span class="st">'Autocorrelation and partial autocorrelation, daily sales, up to 54 days'</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plot_acf(sales, lags<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">55</span>), ax<span class="op">=</span>axes3[<span class="dv">0</span>])</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plot_pacf(sales, lags<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>,<span class="dv">55</span>), ax<span class="op">=</span>axes3[<span class="dv">1</span>], method<span class="op">=</span><span class="st">"ywm"</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Show fig3</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-31-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The sinusoidal pattern in the ACF plot is typical for strong weekly seasonality:</p>
<ul>
<li><p>Sales at T=0 are highly correlated with the sales of the previous day at T=1.</p></li>
<li><p>The correlation declines until T=6, which is the previous value of the next weekday from T=0, and peaks at T=7, which is the previous value of the same weekday.</p></li>
<li><p>The pattern repeats weekly after T=7, with declining strength.</p></li>
</ul>
<p>The PACF plot shows the marginal contribution of each lag to the relationship with the present day value. The partial autocorrelation is highest for lag 1, and significant correlations die out roughly after 14 days. In step 2 of this analysis, we will revisit this plot to derive features from sales lags, after performing time decomposition with model 1.</p>
</section>
<section id="april-2016-earthquake" class="level3">
<h3 class="anchored" data-anchor-id="april-2016-earthquake">April 2016 Earthquake</h3>
<p>One more time effect we will look at is the April 2016 earthquake, a one-off occurrence we need to adjust for in our model. The plots below show the seasonality of sales in April and May, in every year. The black dashed vertical line marks April 16.</p>
<div class="cell" data-execution_count="31">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-32-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>With the earthquake, the sales sharply increased from the expected seasonal pattern and trend, peaked in April 18, then declined and returned to the seasonal expectations around April 22. It doesn’t seem like sales were higher than normal for the rest of April 2016, or in May 2016. We’ll engineer our earthquake feature accordingly.</p>
</section>
</section>
<section id="feature-engineering-1---time-calendar-features" class="level2">
<h2 class="anchored" data-anchor-id="feature-engineering-1---time-calendar-features">Feature engineering 1 - Time &amp; calendar features</h2>
<p>Our main candidate for the time decomposition model is a simple linear regression, so we will focus our feature engineering towards that.</p>
<section id="calendar-effects-weekly-seasonality-features" class="level3">
<h3 class="anchored" data-anchor-id="calendar-effects-weekly-seasonality-features">Calendar effects &amp; weekly seasonality features</h3>
<p>We’ll flag the dates that influence sales considerably with dummy or ordinal features. These columns will take non-zero values if a certain calendar effect is present in a date, and zeroes otherwise.</p>
<p>Sales decline very sharply every year in January 1st, almost to zero. The sales in January 2nd then recover sharply, which is a huge relative increase for one day, so we will flag both dates with dummy features.</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># New year's day features</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"ny1"</span>] <span class="op">=</span> ((df_train.index.day <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">1</span>)).astype(<span class="bu">int</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Set holiday dummies to 0 if NY dummies are 1</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train[<span class="st">"ny1"</span>] <span class="op">==</span> <span class="dv">1</span>, [<span class="st">"local_holiday"</span>, <span class="st">"regional_holiday"</span>, <span class="st">"national_holiday"</span>]] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"ny2"</span>] <span class="op">=</span> ((df_train.index.day <span class="op">==</span> <span class="dv">2</span>) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">1</span>)).astype(<span class="bu">int</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train[<span class="st">"ny2"</span>] <span class="op">==</span> <span class="dv">1</span>, [<span class="st">"local_holiday"</span>, <span class="st">"regional_holiday"</span>, <span class="st">"national_holiday"</span>]] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have considerably higher sales in December due to Christmas and the New Years’ Eve.</p>
<ul>
<li><p>For NY’s eve effects, we can simply flag December 30 and 31st with dummy features.</p></li>
<li><p>For Christmas effects, we will create two integer columns that reflect the ‘strength’ of the Christmas effect on sales, based on day of month. The columns will reach its maximum value in December 23rd, and decline as the date moves away from that. For dates outside December 13-27, these features will take a value of zero. This may not be the most sophisticated way to reflect the Christmas effects on our model, but it should be simple and effective.</p></li>
</ul>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># NY's eve features</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"ny_eve31"</span>] <span class="op">=</span> ((df_train.index.day <span class="op">==</span> <span class="dv">31</span>) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>)).astype(<span class="bu">int</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"ny_eve30"</span>] <span class="op">=</span> ((df_train.index.day <span class="op">==</span> <span class="dv">30</span>) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>)).astype(<span class="bu">int</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>df_train.loc[(df_train[<span class="st">"ny_eve31"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">|</span> (df_train[<span class="st">"ny_eve30"</span>] <span class="op">==</span> <span class="dv">1</span>), [<span class="st">"local_holiday"</span>, <span class="st">"regional_holiday"</span>, <span class="st">"national_holiday"</span>]] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Proximity to Christmas sales peak</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"xmas_before"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>df_train.loc[</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>  (df_train.index.day.isin(<span class="bu">range</span>(<span class="dv">13</span>,<span class="dv">24</span>))) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>), <span class="st">"xmas_before"</span>] <span class="op">=</span> df_train.loc[</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>  (df_train.index.day.isin(<span class="bu">range</span>(<span class="dv">13</span>,<span class="dv">24</span>))) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>)].index.day <span class="op">-</span> <span class="dv">12</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"xmas_after"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>df_train.loc[</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>  (df_train.index.day.isin(<span class="bu">range</span>(<span class="dv">24</span>,<span class="dv">28</span>))) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>), <span class="st">"xmas_after"</span>] <span class="op">=</span> <span class="bu">abs</span>(df_train.loc[</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>  (df_train.index.day.isin(<span class="bu">range</span>(<span class="dv">24</span>,<span class="dv">28</span>))) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">12</span>)].index.day <span class="op">-</span> <span class="dv">27</span>)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>df_train.loc[(df_train[<span class="st">"xmas_before"</span>] <span class="op">!=</span> <span class="dv">0</span>) <span class="op">|</span> (df_train[<span class="st">"xmas_after"</span>] <span class="op">!=</span> <span class="dv">0</span>), [<span class="st">"local_holiday"</span>, <span class="st">"regional_holiday"</span>, <span class="st">"national_holiday"</span>]] <span class="op">=</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To account for the effect of the April 2016 earthquake, we create a feature similar to the ones for Christmas. The feature peaks at April 18th and takes a value of zero for dates outside April 17-22, 2016.</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Strength of earthquake effect on sales</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># April 18 &gt; 17 &gt; 19 &gt; 20 &gt; 21 &gt; 22</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-18"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-17"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-19"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-20"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-21"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>df_train.loc[df_train.index <span class="op">==</span> <span class="st">"2016-04-22"</span>, <span class="st">"quake_after"</span>] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We previously created dummy features to indicate local-regional-national holidays, and special events. There are only a few different events in the dataset, and they differ in nature, so we will break up the events column and create separate dummy features for each event. We already created a feature for the earthquake, so we’ll skip that one.</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Split events, delete events column</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"dia_madre"</span>] <span class="op">=</span> ((df_train[<span class="st">"event"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_train.index.month <span class="op">==</span> <span class="dv">5</span>) <span class="op">&amp;</span> (df_train.index.day.isin([<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">14</span>]))).astype(<span class="bu">int</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"futbol"</span>] <span class="op">=</span> ((df_train[<span class="st">"event"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_train.index.isin(pd.date_range(start <span class="op">=</span> <span class="st">"2014-06-12"</span>, end <span class="op">=</span> <span class="st">"2014-07-13"</span>)))).astype(<span class="bu">int</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"black_friday"</span>] <span class="op">=</span> ((df_train[<span class="st">"event"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_train.index.isin([<span class="st">"2014-11-28"</span>, <span class="st">"2015-11-27"</span>, <span class="st">"2016-11-25"</span>]))).astype(<span class="bu">int</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"cyber_monday"</span>] <span class="op">=</span> ((df_train[<span class="st">"event"</span>] <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (df_train.index.isin([<span class="st">"2014-12-01"</span>, <span class="st">"2015-11-30"</span>, <span class="st">"2016-11-28"</span>]))).astype(<span class="bu">int</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> df_train.drop(<span class="st">"event"</span>, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Holidays and events may lead to an increase in sales in advance, so we will create one lag column for each holiday column, and the Mother’s Day event. These features could be tailored more carefully according to each holiday and event, but we’ll keep it simple.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Holiday-event leads</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"local_lead1"</span>] <span class="op">=</span> df_train[<span class="st">"local_holiday"</span>].shift(<span class="op">-</span><span class="dv">1</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"regional_lead1"</span>] <span class="op">=</span> df_train[<span class="st">"regional_holiday"</span>].shift(<span class="op">-</span><span class="dv">1</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"national_lead1"</span>] <span class="op">=</span> df_train[<span class="st">"national_holiday"</span>].shift(<span class="op">-</span><span class="dv">1</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"diamadre_lead1"</span>] <span class="op">=</span> df_train[<span class="st">"dia_madre"</span>].shift(<span class="op">-</span><span class="dv">1</span>).fillna(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To capture the weekly seasonality in a simple manner, we’ll create 6 dummy features for days of the week. We won’t create one for Monday, since a 0 value for the other 6 columns means Monday.</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Days of week dummies</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"tuesday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">1</span>).astype(<span class="bu">int</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"wednesday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">2</span>).astype(<span class="bu">int</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"thursday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">3</span>).astype(<span class="bu">int</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"friday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">4</span>).astype(<span class="bu">int</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"saturday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">5</span>).astype(<span class="bu">int</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>df_train[<span class="st">"sunday"</span>] <span class="op">=</span> (df_train.index.dayofweek <span class="op">==</span> <span class="dv">6</span>).astype(<span class="bu">int</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we will aggregate the time features by mean. For local and regional holidays, this will give us fractional values between 0 and 1, which is likely a decent way to reflect local and regional holidays’ effects on national sales.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggregate time features by mean</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>time_covars <span class="op">=</span> df_train.drop(columns<span class="op">=</span>[<span class="st">'id'</span>, <span class="st">'store_nbr'</span>, <span class="st">'family'</span>, <span class="st">'sales'</span>, <span class="st">'onpromotion'</span>, <span class="st">'transactions'</span>, <span class="st">'oil'</span>, <span class="st">'city'</span>, <span class="st">'state'</span>, <span class="st">'store_type'</span>, <span class="st">'store_cluster'</span>], axis<span class="op">=</span><span class="dv">1</span>).groupby(<span class="st">"date"</span>).mean(numeric_only<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="trend-monthly-seasonality-features" class="level3">
<h3 class="anchored" data-anchor-id="trend-monthly-seasonality-features">Trend &amp; monthly seasonality features</h3>
<p>In the exploratory analysis, we saw the overall trend can be modeled linearly, but the rate of increase (the slope of the trend line) declines from the start of 2015. To capture this, we will model a piecewise linear trend with one knot at 01-01-2015.</p>
<ul>
<li><p>In effect, the slope of the linear trend will change and decline once, at the knot date. The result will be two linear trend lines added together.</p></li>
<li><p>It’s possible to add more “turns” to a linear trend with more knots, but one is enough in our case. We want the trend to be simple, and robust against seasonal or cyclical fluctuations.</p></li>
</ul>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add piecewise linear trend dummies</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>time_covars[<span class="st">"trend"</span>] <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">1685</span>) <span class="co"># Linear dummy 1</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Knot to be put at period 729</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>time_covars.loc[time_covars.index<span class="op">==</span><span class="st">"2015-01-01"</span>][<span class="st">"trend"</span>] </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Add second linear trend dummy</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>time_covars[<span class="st">"trend_knot"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>time_covars.iloc[<span class="dv">728</span>:,<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">956</span>)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Check start and end of knot</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>time_covars.loc[time_covars[<span class="st">"trend"</span>]<span class="op">&gt;=</span><span class="dv">729</span>][[<span class="st">"trend"</span>, <span class="st">"trend_knot"</span>]] </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>trend</th>
      <th>trend_knot</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2015-01-01</th>
      <td>729</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2015-01-02</th>
      <td>730</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2015-01-03</th>
      <td>731</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2015-01-04</th>
      <td>732</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2015-01-05</th>
      <td>733</td>
      <td>4</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2017-08-11</th>
      <td>1680</td>
      <td>951</td>
    </tr>
    <tr>
      <th>2017-08-12</th>
      <td>1681</td>
      <td>952</td>
    </tr>
    <tr>
      <th>2017-08-13</th>
      <td>1682</td>
      <td>953</td>
    </tr>
    <tr>
      <th>2017-08-14</th>
      <td>1683</td>
      <td>954</td>
    </tr>
    <tr>
      <th>2017-08-15</th>
      <td>1684</td>
      <td>955</td>
    </tr>
  </tbody>
</table>
<p>956 rows × 2 columns</p>
</div>
</div>
</div>
<p>For the monthly seasonality, we will create Fourier features.</p>
<ul>
<li><p>Named after the French mathematician, Fourier series can be used to model any periodic, repeating fluctuation / waveform as sums of numerous sine-cosine pairs.</p></li>
<li><p>We’ll create 5 Fourier pairs (10 columns in total) for 28-period seasonality. This will capture the slight increases and decreases in sales throughout a month, mostly due to proximity to paydays.</p></li>
<li><p>December was an exception to the monthly seasonality pattern, but our Christmas and NY features will adjust for that.</p></li>
</ul>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.tsa.deterministic <span class="im">import</span> DeterministicProcess</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Add Fourier features for monthly seasonality</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>dp <span class="op">=</span> DeterministicProcess(</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  index <span class="op">=</span> time_covars.index,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  constant <span class="op">=</span> <span class="va">False</span>,</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  order <span class="op">=</span> <span class="dv">0</span>, <span class="co"># No trend feature</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  seasonal <span class="op">=</span> <span class="va">False</span>, <span class="co"># No seasonal dummy features</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  period <span class="op">=</span> <span class="dv">28</span>, <span class="co"># 28-period seasonality (28 days, 1 month)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  fourier <span class="op">=</span> <span class="dv">5</span>, <span class="co"># 5 Fourier pairs</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  drop <span class="op">=</span> <span class="va">True</span> <span class="co"># Drop perfectly collinear terms</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>time_covars <span class="op">=</span> time_covars.merge(dp.in_sample(), how<span class="op">=</span><span class="st">"left"</span>, on<span class="op">=</span><span class="st">"date"</span>)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="co"># View Fourier features</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>time_covars.iloc[<span class="dv">0</span>:<span class="dv">5</span>, <span class="op">-</span><span class="dv">10</span>:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>sin(1,28)</th>
      <th>cos(1,28)</th>
      <th>sin(2,28)</th>
      <th>cos(2,28)</th>
      <th>sin(3,28)</th>
      <th>cos(3,28)</th>
      <th>sin(4,28)</th>
      <th>cos(4,28)</th>
      <th>sin(5,28)</th>
      <th>cos(5,28)</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.0000</td>
      <td>1.0000</td>
      <td>0.0000</td>
      <td>1.0000</td>
      <td>0.0000</td>
      <td>1.0000</td>
      <td>0.0000</td>
      <td>1.0000</td>
      <td>0.0000</td>
      <td>1.0000</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>0.2225</td>
      <td>0.9749</td>
      <td>0.4339</td>
      <td>0.9010</td>
      <td>0.6235</td>
      <td>0.7818</td>
      <td>0.7818</td>
      <td>0.6235</td>
      <td>0.9010</td>
      <td>0.4339</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.4339</td>
      <td>0.9010</td>
      <td>0.7818</td>
      <td>0.6235</td>
      <td>0.9749</td>
      <td>0.2225</td>
      <td>0.9749</td>
      <td>-0.2225</td>
      <td>0.7818</td>
      <td>-0.6235</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>0.6235</td>
      <td>0.7818</td>
      <td>0.9749</td>
      <td>0.2225</td>
      <td>0.9010</td>
      <td>-0.4339</td>
      <td>0.4339</td>
      <td>-0.9010</td>
      <td>-0.2225</td>
      <td>-0.9749</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>0.7818</td>
      <td>0.6235</td>
      <td>0.9749</td>
      <td>-0.2225</td>
      <td>0.4339</td>
      <td>-0.9010</td>
      <td>-0.4339</td>
      <td>-0.9010</td>
      <td>-0.9749</td>
      <td>-0.2225</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
</section>
</section>
<section id="model-1---time-effects-decomposition" class="level2">
<h2 class="anchored" data-anchor-id="model-1---time-effects-decomposition">Model 1 - Time effects decomposition</h2>
<p>We will now build our time decomposition linear regression model in Darts, and compare it with some baseline models, as well as some models that are quicker to implement.</p>
<section id="preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing">Preprocessing</h3>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create Darts time series with time feats</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>ts_timecovars <span class="op">=</span> TimeSeries.from_dataframe(</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  time_covars, freq<span class="op">=</span><span class="st">"D"</span>, fill_missing_dates<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our target and covariate Series had 1684 rows each, but the Darts TimeSeries we create from them have 1688 dates. This is likely because we have gaps in our original series. We can check this easily in Darts.</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Scan for gaps</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>ts_timecovars.gaps()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gap_start</th>
      <th>gap_end</th>
      <th>gap_size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2013-12-25</td>
      <td>2013-12-25</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2014-12-25</td>
      <td>2014-12-25</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015-12-25</td>
      <td>2015-12-25</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2016-12-25</td>
      <td>2016-12-25</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>It seems our data is missing values for December 25th in every year (the data for 2017 ends in August). Darts automatically filled in the missing dates to 1688, but we need to fill the missing values in our target and covariate series.</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fill gaps by interpolating missing values</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.dataprocessing.transformers <span class="im">import</span> MissingValuesFiller</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>na_filler <span class="op">=</span> MissingValuesFiller()</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>ts_sales <span class="op">=</span> na_filler.transform(ts_sales)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>ts_timecovars <span class="op">=</span> na_filler.transform(ts_timecovars)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Scan for gaps again</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>ts_timecovars.gaps()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>gap_start</th>
      <th>gap_end</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>
</div>
</div>
<p>Our exploratory analysis showed that the seasonal fluctuations in sales become larger over time. We should use a multiplicative decomposition instead of additive.</p>
<ul>
<li><p>In <strong>additive decomposition</strong>, we decompose a time series as <strong>Trend + Seasonality + Remainder.</strong></p></li>
<li><p>In <strong>multiplicative decomposition</strong>, we decompose a time series as <strong>Trend * Seasonality * Remainder.</strong></p></li>
</ul>
<p>One way of performing multiplicative decomposition is taking the logarithm of the time series and performing additive decomposition, as addition / subtraction in log(x) is equivalent to multiplication / division in x.</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define functions to perform log transformation and reverse it. +1 to avoid zeroes</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> trafo_log(x):</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x.<span class="bu">map</span>(<span class="kw">lambda</span> x: np.log(x<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> trafo_exp(x):</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x.<span class="bu">map</span>(<span class="kw">lambda</span> x: np.exp(x)<span class="op">-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’ll train our time decomposition models on the daily sales data from 2013-2016, and validate their prediction performance on 2017.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Train-validation split: Pre 2017 vs 2017</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>y_train1, y_val1 <span class="op">=</span> trafo_log(ts_sales[:<span class="op">-</span><span class="dv">227</span>]), trafo_log(ts_sales[<span class="op">-</span><span class="dv">227</span>:])</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>x_train1, x_val1 <span class="op">=</span> ts_timecovars[:<span class="op">-</span><span class="dv">227</span>], ts_timecovars[<span class="op">-</span><span class="dv">227</span>:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="model-specification" class="level3">
<h3 class="anchored" data-anchor-id="model-specification">Model specification</h3>
<p>We’ll compare the performance of our linear regression model against a few other models.</p>
<p>Naive drift and naive seasonal are two baseline models, meant to represent the performance of a very simple prediction.</p>
<ul>
<li><p>Naive drift simply fits a straight line from the start to the end of the training data, and extrapolates it.</p></li>
<li><p>Naive seasonal simply repeats the last K values in the training set.</p></li>
</ul>
<p>We’ll also test two simple seasonal models which require little input. These models can capture a trend and one seasonality period, but cannot use other covariates in their predictions, such as our calendar features.</p>
<ul>
<li><p>Fast Fourier Transform is an algorithm that converts a signal from the time domain to the frequency domain, used in many fields such as engineering and music. In our case, we’ll try to model the weekly seasonality waves with FFT, as it is the strongest seasonality in the data, along with a linear trend.</p></li>
<li><p>Exponential smoothing uses exponentially weighted moving averages of a certain number of lags to make predictions. Again, we’ll model the weekly seasonality with a linear trend.</p></li>
</ul>
<p>And finally, we’ll use our tailored linear regression model with piecewise linear trend dummies, Fourier features for monthly seasonality and dummy features for weekly seasonality &amp; calendar effects. We’ll see how much better it performs compared to models that can be specified and applied quickly.</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import models</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.baselines <span class="im">import</span> NaiveDrift, NaiveSeasonal</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.fft <span class="im">import</span> FFT</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.sf_ets <span class="im">import</span> StatsForecastETS <span class="im">as</span> ETS</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.linear_regression_model <span class="im">import</span> LinearRegressionModel</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify baseline models</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>model_drift <span class="op">=</span> NaiveDrift()</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>model_seasonal <span class="op">=</span> NaiveSeasonal(K<span class="op">=</span><span class="dv">7</span>) <span class="co"># Repeat the last week of the training data</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify FFT model</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>model_fft <span class="op">=</span> FFT(</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>  required_matches <span class="op">=</span> {<span class="st">"day_of_week"</span>}, <span class="co"># Try to match the weekdays of the training sequence with the predictions  </span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  nr_freqs_to_keep <span class="op">=</span> <span class="dv">10</span>, <span class="co"># Keep 10 frequencies</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>  trend <span class="op">=</span> <span class="st">"poly"</span>,</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>  trend_poly_degree <span class="op">=</span> <span class="dv">1</span> <span class="co"># Linear trend</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify ETS model</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>model_ets <span class="op">=</span> ETS(</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>  season_length <span class="op">=</span> <span class="dv">7</span>, <span class="co"># Weekly seasonality</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>  model <span class="op">=</span> <span class="st">"AAA"</span> <span class="co"># Additive trend, seasonality and remainder component</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify linear regression model</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>model_linear1 <span class="op">=</span> LinearRegressionModel(</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>  lags_future_covariates <span class="op">=</span> [<span class="dv">0</span>] <span class="co"># Don't create any more lagged covariate values</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="model-validation-predicting-2017-sales" class="level3">
<h3 class="anchored" data-anchor-id="model-validation-predicting-2017-sales">Model validation: Predicting 2017 sales</h3>
<p>We’ll train our models on 2013-2016 sales data, predict the sales for 2017, and score the predictions with a custom function.</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit models on train data (pre-2017), predict validation data (2017)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>model_drift.fit(y_train1)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>pred_drift <span class="op">=</span> model_drift.predict(n <span class="op">=</span> <span class="dv">227</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>model_seasonal.fit(y_train1)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>pred_seasonal <span class="op">=</span> model_seasonal.predict(n <span class="op">=</span> <span class="dv">227</span>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>model_fft.fit(y_train1)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>pred_fft <span class="op">=</span> model_fft.predict(n <span class="op">=</span> <span class="dv">227</span>)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>model_ets.fit(y_train1)</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>pred_ets <span class="op">=</span> model_ets.predict(n <span class="op">=</span> <span class="dv">227</span>)</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>model_linear1.fit(y_train1, future_covariates <span class="op">=</span> x_train1)</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>pred_linear1 <span class="op">=</span> model_linear1.predict(n <span class="op">=</span> <span class="dv">227</span>, future_covariates <span class="op">=</span> x_val1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define model scoring function</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.metrics <span class="im">import</span> mape, rmse, rmsle</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perf_scores(val, pred, model<span class="op">=</span><span class="st">"drift"</span>):</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  scores_dict <span class="op">=</span> {</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"RMSE"</span>: rmse(trafo_exp(val), trafo_exp(pred)), </span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"RMSLE"</span>: rmse(val, pred), </span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"MAPE"</span>: mape(trafo_exp(val), trafo_exp(pred))</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Model: "</span> <span class="op">+</span> model)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> key <span class="kw">in</span> scores_dict:</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>      key <span class="op">+</span> <span class="st">": "</span> <span class="op">+</span> </span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>      <span class="bu">str</span>(<span class="bu">round</span>(scores_dict[key], <span class="dv">4</span>))</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"--------"</span>)  </span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Score models' performance</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val1, pred_drift, model<span class="op">=</span><span class="st">"Naive drift"</span>)</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val1, pred_seasonal, model<span class="op">=</span><span class="st">"Naive seasonal"</span>)</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val1, pred_fft, model<span class="op">=</span><span class="st">"FFT"</span>)</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val1, pred_ets, model<span class="op">=</span><span class="st">"Exponential smoothing"</span>)</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val1, pred_linear1, model<span class="op">=</span><span class="st">"Linear regression"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: Naive drift
RMSE: 899727.1315
RMSLE: 0.8665
MAPE: 161.8275
--------
Model: Naive seasonal
RMSE: 183226.1742
RMSLE: 0.3836
MAPE: 64.2437
--------
Model: FFT
RMSE: 190795.2994
RMSLE: 0.378
MAPE: 60.8149
--------
Model: Exponential smoothing
RMSE: 201526.3126
RMSLE: 0.3956
MAPE: 75.8211
--------
Model: Linear regression
RMSE: 75003.7023
RMSLE: 0.1061
MAPE: 8.1491
--------</code></pre>
</div>
</div>
<p>We see our linear regression model performs much better than the baseline and simple methods tested. It’s also notable that the naive seasonal model beats the ETS model in all metrics, while beating FFT in RMSE.</p>
<ul>
<li>RMSLE stands for root mean squared log error. Log errors penalize underpredictions much more strongly than overpredictions, which could be particularly good for assessing sales predictions, as unfulfilled demand is likely more costly than overstocking. The competition is scored on RMSLE.</li>
<li>Since the naive seasonal model has lower RMSE but higher RMSLE compared to FFT, it’s likely it tends to underpredict compared to FFT.</li>
</ul>
<p>Let’s plot the predictions of our models and compare them visually with the actual values.</p>
<div class="cell" data-execution_count="49">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-50-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The FFT and ETS models actually did a good job of capturing the weekly seasonality pattern in the data, as the shape and timing of the waves in the predictions are similar to the actual values.</p>
<ul>
<li><p>However, the FFT and ETS models almost always overestimated the trend of 2017 sales. This is likely because they modeled the trend with a simple linear term, so it can’t adjust for the slope decline that happens in 2015.</p></li>
<li><p>The naive seasonal model performed close to FFT and ETS by coincidence, because the 7 days of sales it repeated were close to the trend of 2017.</p></li>
<li><p>The naive, FFT and ETS models also couldn’t account for the sharp drop in sales in January 1st, as they don’t take in covariates.</p></li>
<li><p>In contrast, the linear model’s trend and seasonality are both on point, and the January 1st drop, along with the January 2nd recovery, are adjusted for nicely. The model is not able to match some peaks and troughs fully, which are possibly cyclical in nature. That’s where Model 2 will come in.</p></li>
</ul>
</section>
<section id="rolling-crossvalidation" class="level3">
<h3 class="anchored" data-anchor-id="rolling-crossvalidation">Rolling crossvalidation</h3>
<p>We can further evaluate the performance of our model with rolling crossvalidation: This is the practice of training a model with past data up to a certain time point, predicting the next time point(s), adding them to the training data and repeating the process with increasingly wider training windows until the end of the data.</p>
<ul>
<li><p>We’ll start by training the model on 2013 only, as it makes sense to feed a full year of the seasonality patterns to the model.</p></li>
<li><p>Then we’ll predict the next day, add it to the training data, and repeat the process until the end of the data. This could take a long time for more complex models, but it should be fine for linear regression.</p></li>
<li><p>We’ll also retrieve the residuals for each prediction, which will represent the decomposed sales we’ll use as our target variable in the second model.</p></li>
</ul>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Retrieve historical forecasts and decomposed residuals for 2014-2017</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>pred_hist1 <span class="op">=</span> model_linear1.historical_forecasts(</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  trafo_log(ts_sales), </span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  future_covariates <span class="op">=</span> ts_timecovars, start <span class="op">=</span> <span class="dv">365</span>, stride <span class="op">=</span> <span class="dv">1</span>,</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  verbose <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>res_linear1 <span class="op">=</span> trafo_log(ts_sales[<span class="dv">365</span>:]) <span class="op">-</span> pred_hist1</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Score historical forecasts</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>perf_scores(trafo_log(ts_sales[<span class="dv">365</span>:]), pred_hist1, model<span class="op">=</span><span class="st">"Linear regression, historical"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"f566456c9aa94658af47f81bb9b38db5","version_major":2,"version_minor":0}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: Linear regression, historical
RMSE: 99341.6312
RMSLE: 0.1828
MAPE: 13.8001
--------</code></pre>
</div>
</div>
<div class="cell" data-execution_count="51">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-52-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Again, the model captures the trend &amp; seasonality patterns nicely, but the errors due to cyclical effects are even more apparent in 2014 and 2015. If we had modeled the trend non-linearly, such as with an STL decomposition, the trend term would likely respond strongly to these fluctuations, and potentially be overfit for predictions after the training time period.</p>
</section>
<section id="residuals-diagnosis-stationarity" class="level3">
<h3 class="anchored" data-anchor-id="residuals-diagnosis-stationarity">Residuals diagnosis &amp; stationarity</h3>
<p>We’ll now analyze the residuals from our historical forecasts.</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Diagnose linear model 1's innovation residuals</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.utils.statistics <span class="im">import</span> plot_residuals_analysis, plot_pacf</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plot_residuals_analysis(res_linear1)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co"># PACF plot of decomped sales residuals</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span>  plot_pacf(res_linear1, max_lag<span class="op">=</span><span class="dv">56</span>)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.title(<span class="st">"Partial autocorrelation plot, residuals of linear model 1"</span>)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xlabel(<span class="st">"Lags"</span>)</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.ylabel(<span class="st">"PACF"</span>)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">56</span>, <span class="dv">10</span>))</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">56</span>, <span class="dv">1</span>), minor<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.grid(which<span class="op">=</span><span class="st">'minor'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.grid(which<span class="op">=</span><span class="st">'major'</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-53-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-53-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Ideally, we’d want very small residuals that are normally distributed around zero, representing the truly unpredictable remainder of our models. This is not the case overall, so there’s room for improvement in our predictions.</p>
<ul>
<li><p>We see residuals for 2014-2015 especially deviate more from zero. This is likely due to the cyclical behavior we observed in this period. Our second model will aim to account for this.</p></li>
<li><p>The overall distribution of the residuals is not too far from a normal distribution around zero, but the right tail is bigger, indicating some values are strongly underpredicted. These are mostly from 2014-2015.</p></li>
<li><p>The PACF plot shows strong autocorrelation with lag 1, which means we’ll likely include a sales lag in the second model. There are also small, barely significant partial autocorrelations after lag 2.</p></li>
</ul>
<p>A <strong>stationary time series</strong> is one that doesn’t change depending on time. Ideally, we’d want our residuals to be stationary to consider our modeling complete. We can test their stationarity with two statistical tests. First is the Kwiatkowski-Phillips-Schmidt-Shin test.</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import KPSS and ADF tests</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.utils.statistics <span class="im">import</span> stationarity_test_kpss, stationarity_test_adf</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"KPSS test p-value: "</span> <span class="op">+</span> </span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  stationarity_test_kpss(res_linear1)[<span class="dv">1</span>].astype(<span class="bu">str</span>)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null rejected = data is non-stationary</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KPSS test p-value: 0.01</code></pre>
</div>
</div>
<p>The null hypothesis for the KPSS test is stationarity around a constant value. With a p-value smaller than 0.01, the null is rejected, so the test suggests our residuals are non-stationary.</p>
<p>Second is the Augmented Dickey-Fuller test.</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ADF test p-value: "</span> <span class="op">+</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  stationarity_test_adf(res_linear1)[<span class="dv">1</span>].astype(<span class="bu">str</span>)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null rejected = data is stationary around a constant</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>ADF test p-value: 7.49538399004551e-05</code></pre>
</div>
</div>
<p>The null hypothesis for the ADF test is the presence of a unit root, while the alternative hypothesis is stationarity around a constant. With a very small p-value, the null is rejected and the alternative is accepted, so the test suggests our residuals are stationary around a constant, conflicting with the KPSS test.</p>
</section>
<section id="time-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="time-decomposition">Time decomposition</h3>
<p>We will train our second model on the time-decomposed sales, which are the residuals of the first model.</p>
<ul>
<li><p>Since 2013-2016 will serve as our training data, we need to fit the first model on 2013-2016, and retrieve the fitted residuals to serve as training data for the second model, but Darts doesn’t allow predictions on the training data (which makes sense, as this is normally a mistake if the goal is to evaluate model performance).</p></li>
<li><p>Instead, it’s possible to use the <code>model_linear1.residuals()</code> method, which returns the residuals from rolling crossvalidation as performed previously, but this will lead to higher residuals for the earlier days in our data, as they will be retrieved from models fitted on small portions of our available data, without seeing all the examples of the time patterns we want to remove.</p></li>
<li><p>Since we are ultimately interested in improving our model’s performance in 2017 predictions, and we already validated model 1 on 2017, we’ll perform the final time decomposition in sklearn, which allows predictions on the fitted data.</p></li>
</ul>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform time decomposition in Sklearn</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Retrieve Darts target and features with filled gaps</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>sales <span class="op">=</span> ts_sales.pd_series()</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>time_covars <span class="op">=</span> ts_timecovars.pd_dataframe()</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Train-test split</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>y_train, y_val <span class="op">=</span> trafo_log(sales[:<span class="op">-</span><span class="dv">227</span>]), trafo_log(sales[<span class="op">-</span><span class="dv">227</span>:])</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>x_train, x_val <span class="op">=</span> time_covars.iloc[:<span class="op">-</span><span class="dv">227</span>,], time_covars.iloc[<span class="op">-</span><span class="dv">227</span>:,]</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit &amp; predict on 13-16, retrieve residuals</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>model_decomp <span class="op">=</span> LinearRegression()</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>model_decomp.fit(x_train, y_train)</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>pred1 <span class="op">=</span> model_decomp.predict(x_train)</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>res1 <span class="op">=</span> y_train <span class="op">-</span> pred1</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict on 17, retrieve residuals</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>pred2 <span class="op">=</span> model_decomp.predict(x_val)</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>res2 <span class="op">=</span> y_val <span class="op">-</span> pred2</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Concatenate residuals to get decomposed sales</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>sales_decomp <span class="op">=</span> pd.concat([res1, res2])</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Concatenate predictions to get model 1 predictions</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>preds_model1 <span class="op">=</span> pd.Series(np.concatenate((pred1, pred2)), index <span class="op">=</span> sales_decomp.index)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, preds_model1 are the predictions of model 1 on the entire dataset, after being fitted on 2013-2016. sales_decomp are the residuals of these predictions. We’ll fit model 2 on sales_decomp, and add preds_model1 to its predictions to achieve our final hybrid predictions.</p>
</section>
</section>
<section id="exploratory-analysis-2---lags-covariates" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-analysis-2---lags-covariates">Exploratory analysis 2 - Lags &amp; covariates</h2>
<p>Now we will explore the sales lags &amp; covariate time series as possible predictors for our second model.</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggregate daily covariates from df_train: oil, onpromotion, transactions</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>covars <span class="op">=</span> df_train.groupby(<span class="st">"date"</span>).agg(</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a> { <span class="st">"oil"</span>: <span class="st">"mean"</span>,</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"onpromotion"</span>: <span class="st">"sum"</span>,</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"transactions"</span>: <span class="st">"mean"</span>}</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge decomposed sales and covariates</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>sales_covariates <span class="op">=</span> covars.merge(sales_decomp.rename(<span class="st">"sales"</span>), on <span class="op">=</span> <span class="st">"date"</span>, how <span class="op">=</span> <span class="st">"left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="covariates-stationarity-differencing" class="level3">
<h3 class="anchored" data-anchor-id="covariates-stationarity-differencing">Covariates stationarity &amp; differencing</h3>
<p>Oil, onpromotion and transactions are time series that we will consider as predictors of sales.</p>
<ul>
<li><p>However, we performed time decomposition on sales, removing effects of time.</p></li>
<li><p>Our covariate series may display their own time effects and seasonalities. We can use stationarity tests to quickly check for this.</p></li>
<li><p>If a covariate is non-stationary, a quick way to possibly make it stationary is differencing: Subtracting each value from the value of the previous period. This will give us the change in each period, instead of the absolute value.</p></li>
</ul>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test stationarity of covariates</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.tsa.stattools <span class="im">import</span> kpss, adfuller</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"KPSS test p-value: "</span> <span class="op">+</span> </span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  kpss(sales_covariates[<span class="st">"oil"</span>])[<span class="dv">1</span>].astype(<span class="bu">str</span>)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null rejected = data is non-stationary</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ADF test p-value: "</span> <span class="op">+</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  adfuller(sales_covariates[<span class="st">"oil"</span>])[<span class="dv">1</span>].astype(<span class="bu">str</span>)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null accepted = data is non-stationary</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KPSS test p-value: 0.01
ADF test p-value: 0.8027065796825488</code></pre>
</div>
</div>
<p>Both the KPSS and ADF test suggest the oil time series is non-stationary, so we’ll difference it. If one covariate is differenced, it makes sense to difference the others as well.</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Difference the covariates</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sktime.transformations.series.difference <span class="im">import</span> Differencer</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> Differencer(lags <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>sales_covariates[</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  [<span class="st">'oil'</span>, <span class="st">'onpromotion'</span>, <span class="st">'transactions'</span>]] <span class="op">=</span> diff.fit_transform(</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    sales_covariates[[<span class="st">'oil'</span>, <span class="st">'onpromotion'</span>, <span class="st">'transactions'</span>]])</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>sales_covariates</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>oil</th>
      <th>onpromotion</th>
      <th>transactions</th>
      <th>sales</th>
    </tr>
    <tr>
      <th>date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>-0.7649</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>0.0000</td>
      <td>0.0000</td>
      <td>92445.0000</td>
      <td>0.0696</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>-0.1507</td>
      <td>0.0000</td>
      <td>-14711.0000</td>
      <td>0.2949</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>0.1330</td>
      <td>0.0000</td>
      <td>-10.0000</td>
      <td>0.1230</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>0.0236</td>
      <td>0.0000</td>
      <td>15079.0000</td>
      <td>0.1126</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2017-08-11</th>
      <td>0.2184</td>
      <td>6262.0000</td>
      <td>6487.0000</td>
      <td>-0.1136</td>
    </tr>
    <tr>
      <th>2017-08-12</th>
      <td>-0.3290</td>
      <td>-5867.0000</td>
      <td>376.0000</td>
      <td>-0.3183</td>
    </tr>
    <tr>
      <th>2017-08-13</th>
      <td>-0.3290</td>
      <td>971.0000</td>
      <td>-3934.0000</td>
      <td>-0.2906</td>
    </tr>
    <tr>
      <th>2017-08-14</th>
      <td>-0.3290</td>
      <td>-1240.0000</td>
      <td>-545.0000</td>
      <td>-0.1182</td>
    </tr>
    <tr>
      <th>2017-08-15</th>
      <td>-0.0162</td>
      <td>2562.0000</td>
      <td>1113.0000</td>
      <td>-0.0716</td>
    </tr>
  </tbody>
</table>
<p>1684 rows × 4 columns</p>
</div>
</div>
</div>
<p>Now our covariate columns all represent the change in each covariate compared to the previous period.</p>
</section>
<section id="sales-features" class="level3">
<h3 class="anchored" data-anchor-id="sales-features">Sales features</h3>
<p>Let’s evaluate features derived from sales lags as possible predictors. We’ll start with autocorrelation plots.</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.graphics.tsaplots <span class="im">import</span> plot_pacf <span class="im">as</span> pacf_tsa</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sktime.utils.plotting <span class="im">import</span> plot_lags</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> pearsonr, spearmanr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="60">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-61-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As we saw in model 1’s residuals analysis, sales lag 1 makes a strong contribution to the partial autocorrelation, while lags 2 to 7 make weak but significant contributions.</p>
<p>Linear correlation may not always do justice to the relationship between two variables, so let’s look at the scatterplots of sales with its first 9 lags.</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FIG9: Sales lag scatterplots</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>fig9, axes9 <span class="op">=</span> plot_lags(</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  sales_covariates[<span class="st">"sales"</span>], lags <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>],</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  suptitle <span class="op">=</span> <span class="st">"Sales lags"</span>)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Show fig9</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-62-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It doesn’t look like any lag after 1 displays a considerably different relationship with sales.</p>
<p>We can also consider a rolling feature, such as a moving average.</p>
<ul>
<li><p>Since we know lag 1 is the most important lag, an exponentially weighted moving average makes sense. This type of moving average puts more weight on recent lags, and less on older lags.</p></li>
<li><p>A weekly period makes sense, as that was a strong seasonal period in the data, and the significance of partial autocorrelations die out after lag 7.</p></li>
</ul>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate 7-day exponential moving average of sales lags</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"sales_ema7"</span>] <span class="op">=</span> sales_covariates[<span class="st">"sales"</span>].rolling(</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  window <span class="op">=</span> <span class="dv">7</span>, min_periods <span class="op">=</span> <span class="dv">1</span>, center <span class="op">=</span> <span class="va">False</span>, win_type <span class="op">=</span> <span class="st">"exponential"</span>).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="63">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-64-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We can see sales EMA7 is a good linear predictor of sales, similar to lag 1. Let’s compare lag 1’s correlation with sales to EMA7’s correlation with sales.</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Correlation of sales and lag 1</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>pearsonr(sales_covariates[<span class="st">"sales"</span>], sales_covariates[<span class="st">"sales"</span>].shift(<span class="dv">1</span>).fillna(method<span class="op">=</span><span class="st">"bfill"</span>)) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>PearsonRResult(statistic=0.790350805157687, pvalue=0.0)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Correlation of sales and ema7</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>pearsonr(sales_covariates[<span class="st">"sales"</span>], sales_covariates[<span class="st">"sales_ema7"</span>]) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>PearsonRResult(statistic=0.6812765481062973, pvalue=3.882061264270767e-230)</code></pre>
</div>
</div>
<p>Lag 1 comes out as the stronger linear predictor, but EMA7 is a good one too. We can include both as features, so lags 2-7 can contribute to the model in some way.</p>
</section>
<section id="oil-features" class="level3">
<h3 class="anchored" data-anchor-id="oil-features">Oil features</h3>
<p>The oil price change of one day is not likely to mean much by itself, and the effect of oil prices on the economy likely takes some time to manifest.</p>
<ul>
<li><p>Therefore, we’ll just consider moving averages of the oil prices as features.</p></li>
<li><p>These won’t be exponentially weighted averages, as recent oil prices likely require time to make their effect on sales. It’s even possible oil prices with a certain degree of lag are the more important predictors compared to more recent oil prices.</p></li>
</ul>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate oil MAs</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>oil_ma <span class="op">=</span> sales_covariates.assign(</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  oil_ma7 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">7</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  oil_ma14 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">14</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  oil_ma28 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">28</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>  oil_ma84 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">84</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  oil_ma168 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">168</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>  oil_ma336 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">336</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="67">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-68-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We don’t see particularly strong relationships between oil price change MAs and sales, though the monthly MA is the most notable one with a correlation of -0.2, so we will use that as a feature.</p>
<p>Since we need 28 past periods to calculate this MA for a 29th period, we’ll have missing values for the first 28 periods in our data. After some iteration, these were interpolated decently with a second-order spline interpolation.</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep monthly oil MAs as a feature</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"oil_ma28"</span>] <span class="op">=</span> sales_covariates[<span class="st">"oil"</span>].rolling(window <span class="op">=</span> <span class="dv">28</span>, center <span class="op">=</span> <span class="va">False</span>).mean()</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Spline interpolation for missing values</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"oil_ma28"</span>] <span class="op">=</span> sales_covariates[<span class="st">"oil_ma28"</span>].interpolate(</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  method <span class="op">=</span> <span class="st">"spline"</span>, order <span class="op">=</span> <span class="dv">2</span>, limit_direction <span class="op">=</span> <span class="st">"both"</span>)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Check quality of interpolation</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"oil"</span>].plot()</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"oil_ma28"</span>].plot()</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.title(<span class="st">"Oil price change and its 28-day moving average, first 28 MAs interpolated"</span>)</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-69-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="onpromotion-features" class="level3">
<h3 class="anchored" data-anchor-id="onpromotion-features">Onpromotion features</h3>
<p>Onpromotion is the number of items that are on sale, aggregated across all stores and categories. We’ll start exploring the relationship between onpromotion and sales using a cross-correlation plot: The correlations of sales at time 0, with lags and leads of onpromotion. Since the supermarket chain controls the number of items that will go on sale, it may be feasible to use leading values of onpromotion as predictors.</p>
<div class="cell" data-execution_count="69">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-70-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Single lags / leads of onpromotion don’t display any significant correlations with sales, though there is a repeating pattern of likely six days. Let’s look at the scatterplots of sales at time 0, with four of the more relatively significant lags (lag 0 being the present value of onpromotion).</p>
<div class="cell" data-execution_count="70">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-71-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Again, no significant relationship between single onpromotion lags and sales. Let’s consider moving averages.</p>
<div class="cell" data-execution_count="71">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-72-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The monthly and quarterly MA of onpromotion seems to be slightly positively correlated with sales. We’ll use the monthly MA as a feature, as we would have to fill in too many missing values for the quarterly MA.</p>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep monthly onpromotion MAs as a feature</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"onp_ma28"</span>] <span class="op">=</span> sales_covariates[<span class="st">"onpromotion"</span>].rolling(window <span class="op">=</span> <span class="dv">28</span>, center <span class="op">=</span> <span class="va">False</span>).mean()</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Spline interpolation for missing values</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"onp_ma28"</span>] <span class="op">=</span> sales_covariates[<span class="st">"onp_ma28"</span>].interpolate(</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  method <span class="op">=</span> <span class="st">"spline"</span>, order <span class="op">=</span> <span class="dv">2</span>, limit_direction <span class="op">=</span> <span class="st">"both"</span>)</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Check quality of interpolation</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"onpromotion"</span>].plot()</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"onp_ma28"</span>].plot()</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.title(<span class="st">"Onpromotion change and its 28-day moving average, first 28 MAs interpolated"</span>)</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-73-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The daily changes in onpromotion are practically zero roughly until Q1 2014. Afterwards, changes in onpromotion became increasingly larger, which probably hints at a macroeconomic shift in 2014. The cyclicality in our data becomes especially prominent in 2014 as well.</p>
</section>
<section id="transactions-features" class="level3">
<h3 class="anchored" data-anchor-id="transactions-features">Transactions features</h3>
<p>Finally, we have the number of transactions, aggregated across all stores.</p>
<ul>
<li><p>This is most likely to be a current predictor of sales, i.e.&nbsp;days with higher transactions are likely to be days with higher sales.</p></li>
<li><p>Still, recent levels of transactions may help us predict future sales.</p></li>
<li><p>The transactions data is only available for the training dataset (up to mid-August 2017), and not for the testing dataset (15 days after the training dataset).</p></li>
<li><p>We can freely consider transactions as a feature for Part 1 of this analysis, but in Part 2, we’ll aim to predict the testing data and make a competition submission, so we’ll only be able to consider lag 15 or older values of transactions as features.</p></li>
<li><p>Lag 15 is marked with a red dashed vertical line in the cross-correlation plot below.</p></li>
</ul>
<div class="cell" data-execution_count="73">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-74-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Again, single transactions lags don’t display strong correlations with sales. Unlike onpromotion, there doesn’t seem to be a repeating pattern either. Lags 0-3 are relatively stronger, so let’s see their scatterplots.</p>
<div class="cell" data-execution_count="74">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-75-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As we expected, the present value of transactions have a weak, but relatively stronger positive relationship with the value of sales compared to the lags.</p>
<ul>
<li><p>However, the correlation and the line is impacted by a few outliers with particularly low or high values for transactions, while the relationship seems even weaker for the vast majority of observations.</p></li>
<li><p>This likely tells us that a huge drop / increase in transactions is likely to affect sales a bit, but usual fluctuations in transactions doesn’t tell much about the sales.</p></li>
</ul>
<p>Let’s consider moving averages of changes in transactions, as a possible indicator of recent sales activity.</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FIG13: Transactions MAs</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>fig13, axes13 <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> fig13.suptitle(<span class="st">"Transactions change moving averages &amp; decomposed sales"</span>)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate MAs without min_periods = 1</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>trns_ma <span class="op">=</span> sales_covariates.assign(</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>  trns_ma7 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"transactions"</span>].rolling(window <span class="op">=</span> <span class="dv">7</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>  trns_ma14 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"transactions"</span>].rolling(window <span class="op">=</span> <span class="dv">14</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  trns_ma28 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"transactions"</span>].rolling(window <span class="op">=</span> <span class="dv">28</span>, center <span class="op">=</span> <span class="va">False</span>).mean(),</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>  trns_ma84 <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">"transactions"</span>].rolling(window <span class="op">=</span> <span class="dv">84</span>, center <span class="op">=</span> <span class="va">False</span>).mean()</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a><span class="co"># MA7</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sns.regplot(</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>  data <span class="op">=</span> trns_ma,</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="st">"trns_ma7"</span>,</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>  y <span class="op">=</span> <span class="st">"sales"</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">0</span>].set_xlabel(<span class="st">"weekly MA"</span>)</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">0</span>].annotate(</span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Corr=</span><span class="sc">{:.2f}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>      spearmanr(trns_ma[<span class="st">"trns_ma7"</span>], trns_ma[<span class="st">"sales"</span>], nan_policy<span class="op">=</span><span class="st">'omit'</span>)[<span class="dv">0</span>]</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>      ), </span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>      xy<span class="op">=</span>(<span class="fl">.6</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span><span class="st">"axes fraction"</span>, bbox<span class="op">=</span><span class="bu">dict</span>(alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a><span class="co"># MA14</span></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sns.regplot(</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>  data <span class="op">=</span> trns_ma,</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="st">"trns_ma14"</span>,</span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>  y <span class="op">=</span> <span class="st">"sales"</span></span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">1</span>].set_xlabel(<span class="st">"biweekly MA"</span>)</span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">0</span>,<span class="dv">1</span>].annotate(</span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Corr=</span><span class="sc">{:.2f}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>      spearmanr(trns_ma[<span class="st">"trns_ma14"</span>], trns_ma[<span class="st">"sales"</span>], nan_policy<span class="op">=</span><span class="st">'omit'</span>)[<span class="dv">0</span>]</span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a>      ), </span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a>      xy<span class="op">=</span>(<span class="fl">.6</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span><span class="st">"axes fraction"</span>, bbox<span class="op">=</span><span class="bu">dict</span>(alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a><span class="co"># MA28</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sns.regplot(</span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">0</span>],</span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a>  data <span class="op">=</span> trns_ma,</span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="st">"trns_ma28"</span>,</span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a>  y <span class="op">=</span> <span class="st">"sales"</span></span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">0</span>].set_xlabel(<span class="st">"monthly MA"</span>)</span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">0</span>].annotate(</span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Corr=</span><span class="sc">{:.2f}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a>      spearmanr(trns_ma[<span class="st">"trns_ma28"</span>], trns_ma[<span class="st">"sales"</span>], nan_policy<span class="op">=</span><span class="st">'omit'</span>)[<span class="dv">0</span>]</span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>      ), </span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a>      xy<span class="op">=</span>(<span class="fl">.6</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span><span class="st">"axes fraction"</span>, bbox<span class="op">=</span><span class="bu">dict</span>(alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb66-57"><a href="#cb66-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-58"><a href="#cb66-58" aria-hidden="true" tabindex="-1"></a><span class="co"># MA84</span></span>
<span id="cb66-59"><a href="#cb66-59" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sns.regplot(</span>
<span id="cb66-60"><a href="#cb66-60" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb66-61"><a href="#cb66-61" aria-hidden="true" tabindex="-1"></a>  data <span class="op">=</span> trns_ma,</span>
<span id="cb66-62"><a href="#cb66-62" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> <span class="st">"trns_ma84"</span>,</span>
<span id="cb66-63"><a href="#cb66-63" aria-hidden="true" tabindex="-1"></a>  y <span class="op">=</span> <span class="st">"sales"</span></span>
<span id="cb66-64"><a href="#cb66-64" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-65"><a href="#cb66-65" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">1</span>].set_xlabel(<span class="st">"quarterly MA"</span>)</span>
<span id="cb66-66"><a href="#cb66-66" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> axes13[<span class="dv">1</span>,<span class="dv">1</span>].annotate(</span>
<span id="cb66-67"><a href="#cb66-67" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Corr=</span><span class="sc">{:.2f}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb66-68"><a href="#cb66-68" aria-hidden="true" tabindex="-1"></a>      spearmanr(trns_ma[<span class="st">"trns_ma84"</span>], trns_ma[<span class="st">"sales"</span>], nan_policy<span class="op">=</span><span class="st">'omit'</span>)[<span class="dv">0</span>]</span>
<span id="cb66-69"><a href="#cb66-69" aria-hidden="true" tabindex="-1"></a>      ), </span>
<span id="cb66-70"><a href="#cb66-70" aria-hidden="true" tabindex="-1"></a>      xy<span class="op">=</span>(<span class="fl">.6</span>, <span class="fl">.9</span>), xycoords<span class="op">=</span><span class="st">"axes fraction"</span>, bbox<span class="op">=</span><span class="bu">dict</span>(alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb66-71"><a href="#cb66-71" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb66-72"><a href="#cb66-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-73"><a href="#cb66-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Show fig13</span></span>
<span id="cb66-74"><a href="#cb66-74" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb66-75"><a href="#cb66-75" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-76-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The MAs are much more significant than single lags, though the correlations are still likely impacted by extreme values. Still, these features could help our model adjust for extreme increases / decreases in transactions. We’ll keep the weekly MA as it has the strongest linear relationship, and will create the fewest number of missing values to fill in.</p>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep weekly transactions MA</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"trns_ma7"</span>] <span class="op">=</span> sales_covariates[<span class="st">"transactions"</span>].rolling(window <span class="op">=</span> <span class="dv">7</span>, center <span class="op">=</span> <span class="va">False</span>).mean()</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Backwards linear interpolation</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>sales_covariates[<span class="st">"trns_ma7"</span>] <span class="op">=</span> sales_covariates[<span class="st">"trns_ma7"</span>].interpolate(<span class="st">"linear"</span>, limit_direction <span class="op">=</span> <span class="st">"backward"</span>)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Check quality of interpolation</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"transactions"</span>].plot()</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> sales_covariates[<span class="st">"trns_ma7"</span>].plot()</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.title(<span class="st">"Transactions change and its 7-day moving average, first 7 MAs interpolated"</span>)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-77-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We can see the sharp drop in transactions on January 1st, and the recovery on January 2nd, reflected both in the time series plot of transactions changes, and its weekly moving average.</p>
</section>
</section>
<section id="model-2---lags-covariates" class="level2">
<h2 class="anchored" data-anchor-id="model-2---lags-covariates">Model 2 - Lags &amp; covariates</h2>
<section id="preprocessing-1" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing-1">Preprocessing</h3>
<p>We repeat some preprocessing steps for Model 2.</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop original covariates &amp; target</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>lags_covars <span class="op">=</span> sales_covariates.drop(</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  [<span class="st">'oil'</span>, <span class="st">'onpromotion'</span>, <span class="st">'transactions'</span>, <span class="st">'sales'</span>], axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Make Darts TS with selected covariates</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>ts_lagscovars <span class="op">=</span> TimeSeries.from_dataframe(</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  lags_covars, freq<span class="op">=</span><span class="st">"D"</span>)</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Make Darts TS with decomposed sales</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>ts_decomp <span class="op">=</span> TimeSeries.from_series(sales_decomp.rename(<span class="st">"sales"</span>), freq<span class="op">=</span><span class="st">"D"</span>)</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Make Darts TS with model 1 predictions</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>ts_preds1 <span class="op">=</span> TimeSeries.from_series(preds_model1.rename(<span class="st">"sales"</span>), freq<span class="op">=</span><span class="st">"D"</span>)</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Fill gaps in TS</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>ts_decomp <span class="op">=</span> na_filler.transform(ts_decomp)</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>ts_lagscovars <span class="op">=</span> na_filler.transform(ts_lagscovars)</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Train-test split (pre-post 2017)</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>y_train2, y_val2 <span class="op">=</span> ts_decomp[:<span class="op">-</span><span class="dv">227</span>], trafo_log(ts_sales[<span class="op">-</span><span class="dv">227</span>:])</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>x_train2, x_val2 <span class="op">=</span> ts_lagscovars[:<span class="op">-</span><span class="dv">227</span>], ts_lagscovars[<span class="op">-</span><span class="dv">227</span>:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In model 1, our features were trend dummies, Fourier pairs and binary / ordinal features for calendar effects, none of which required scaling. In this model, we have covariates of different natures and value ranges. For example, the oil price changes are often fractional, while changes in transactions are often in the thousands. The former reflects a unit price, the latter reflects a count. Therefore, we’ll scale and center our features to avoid domination by features with large values.</p>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale covariates</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.dataprocessing.transformers <span class="im">import</span> Scaler</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> Scaler(StandardScaler())</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>x_train2 <span class="op">=</span> scaler.fit_transform(x_train2)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>x_val2 <span class="op">=</span> scaler.transform(x_val2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="model-specification-1" class="level3">
<h3 class="anchored" data-anchor-id="model-specification-1">Model specification</h3>
<p>We’ll use the same baseline models as we did in model 1. We’ll compare them with an ARIMA model, another linear regression, and a random forest model.</p>
<ul>
<li><p>ARIMA models combine <strong>autoregressive models (AR)</strong> and <strong>moving average models (MA)</strong>.</p>
<ul>
<li><p>An AR model of <strong>order p</strong> uses the linear combination of <strong>past p values</strong> of a series as predictors, to forecast its future values.</p></li>
<li><p>A MA model of <strong>order q</strong> performs regression on the <strong>past q forecast errors</strong> of a series to forecast its future values. It can be thought of as a weighted moving average of the past q forecast errors.</p></li>
<li><p>The <strong>order d</strong> indicates the order of differentiation previously applied to the target series.</p></li>
<li><p>The ARIMA model (at least this implementation) doesn’t take in other covariates.</p></li>
</ul></li>
<li><p>A random forest builds <strong>an N number of decision trees</strong>, each with <strong>an M number of randomly selected predictors</strong> out of all the predictors in the data. The predictions of each tree are combined with a voting system, yielding an <strong>ensemble prediction</strong> robust against overfitting.</p>
<ul>
<li><p>Tree-based models can perform feature selection to a degree, capture non-linear relationships, and discover interactions between predictions. They can’t extrapolate a relationship outside the value ranges in the training set, so we didn’t consider them for the time decomposition model.</p></li>
<li><p>We could also include a more capable tree-based gradient boosting algorithm such as XGBoost, but these often require <a href="https://github.com/AhmetZamanis/LoanRequestClassification/blob/main/Report.md#xgboost">extensive hyperparameter tuning</a> to perform at their best, so we will skip it for part 1 of this analysis. In contrast, the random forest has few hyperparameters, and the default settings often do well without needing tuning.</p></li>
</ul></li>
</ul>
<div class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import models</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.baselines <span class="im">import</span> NaiveDrift, NaiveSeasonal</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.arima <span class="im">import</span> ARIMA</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.linear_regression_model <span class="im">import</span> LinearRegressionModel</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> darts.models.forecasting.random_forest <span class="im">import</span> RandomForest</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify baseline models</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>model_drift <span class="op">=</span> NaiveDrift()</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>model_seasonal <span class="op">=</span> NaiveSeasonal(K<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify ARIMA model</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>model_arima <span class="op">=</span> ARIMA(</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>  p <span class="op">=</span> <span class="dv">7</span>, <span class="co"># AR model of order 7 </span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>  d <span class="op">=</span> <span class="dv">0</span>, <span class="co"># No MA model</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>  q <span class="op">=</span> <span class="dv">0</span>, <span class="co"># No differentiation applied to target</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>  trend <span class="op">=</span> <span class="st">"n"</span>, <span class="co"># No trend</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>  random_state <span class="op">=</span> <span class="dv">1923</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify second linear regression model</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>model_linear2 <span class="op">=</span> LinearRegressionModel(</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>  lags <span class="op">=</span> <span class="dv">1</span>, <span class="co"># Target lag 1</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>  lags_future_covariates <span class="op">=</span> [<span class="dv">0</span>] <span class="co"># No covariate lags</span></span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify random forest model  </span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>model_forest <span class="op">=</span> RandomForest(</span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a>  lags <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">6</span>, <span class="op">-</span><span class="dv">7</span>], <span class="co"># Target lags that can be used</span></span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a>  lags_future_covariates <span class="op">=</span> [<span class="dv">0</span>], <span class="co"># No covariate lags</span></span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>  random_state <span class="op">=</span> <span class="dv">1923</span>,</span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>  n_jobs <span class="op">=</span> <span class="op">-</span><span class="dv">2</span> <span class="co"># Use all but one of the CPUs</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As with model 1, our naive seasonal model will repeat the last 7 values in the training data. This was the most significant seasonality period before time decomposition. Now it appears to be the most significant period for cyclical effects.</p>
<ul>
<li><p>To determine the orders of the AR and MA components in the ARIMA model, we look at the ACF and PACF plots of decomposed sales (see <a href="#sales-features">Sales features</a>).</p>
<ul>
<li><p>An ARIMA model of (p, d, 0) may be suitable if the ACF plot shows exponential / sinusoidal decline, and the last significant spike in the PACF plot is at lag p.</p></li>
<li><p>Accordingly, we specify a (p = 7, d = 0, q = 0) ARIMA model. This amounts to an AR(7) model, with no MA component.</p></li>
<li><p>We specify a differencing order of 0 (d = 0), as our target is already decomposed of time effects, so we didn’t difference it. We do not perform detrending either.</p></li>
</ul></li>
<li><p>Our linear regression model will take in sales lag 1, sales EMA7, oil MA28, onpromotion MA28 and transactions MA7 as predictors.</p></li>
<li><p>The random forest model is capable of feature selection to a degree, so we will feed it the same predictors as the linear regression model, plus lags 2-7 which were slightly significant on their own.</p></li>
</ul>
</section>
<section id="model-validation-predicting-2017-sales-1" class="level3">
<h3 class="anchored" data-anchor-id="model-validation-predicting-2017-sales-1">Model validation: Predicting 2017 sales</h3>
<p>Let’s train our models on the decomposed sales of 2013-2016, predict the values for 2017, and add these to the 2017 predictions of model 1 to retrieve our final, hybrid model predictions.</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit models on train data (pre-2017), predict validation data (2017)</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>model_drift.fit(y_train2)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>pred_drift2 <span class="op">=</span> model_drift.predict(n <span class="op">=</span> <span class="dv">227</span>) <span class="op">+</span> ts_preds1[<span class="op">-</span><span class="dv">227</span>:]</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>model_seasonal.fit(y_train2)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>pred_seasonal2 <span class="op">=</span> model_seasonal.predict(n <span class="op">=</span> <span class="dv">227</span>) <span class="op">+</span> ts_preds1[<span class="op">-</span><span class="dv">227</span>:]</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>model_arima.fit(y_train2)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>pred_arima <span class="op">=</span> model_arima.predict(n <span class="op">=</span> <span class="dv">227</span>) <span class="op">+</span> ts_preds1[<span class="op">-</span><span class="dv">227</span>:]</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>model_linear2.fit(y_train2, future_covariates <span class="op">=</span> x_train2)</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>pred_linear2 <span class="op">=</span> model_linear2.predict(</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> <span class="dv">227</span>, future_covariates <span class="op">=</span> x_val2) <span class="op">+</span> ts_preds1[<span class="op">-</span><span class="dv">227</span>:]</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>model_forest.fit(y_train2, future_covariates <span class="op">=</span> x_train2)</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>pred_forest <span class="op">=</span> model_forest.predict(</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> <span class="dv">227</span>, future_covariates <span class="op">=</span> x_val2) <span class="op">+</span> ts_preds1[<span class="op">-</span><span class="dv">227</span>:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Score models' performance</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val2, pred_drift2, model<span class="op">=</span><span class="st">"Naive drift"</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val2, pred_seasonal2, model<span class="op">=</span><span class="st">"Naive seasonal"</span>)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val2, pred_arima, model<span class="op">=</span><span class="st">"ARIMA"</span>)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val2, pred_linear2, model<span class="op">=</span><span class="st">"Linear"</span>)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>perf_scores(y_val2, pred_forest, model<span class="op">=</span><span class="st">"Random forest"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: Naive drift
RMSE: 137822.5506
RMSLE: 0.2019
MAPE: 15.5944
--------
Model: Naive seasonal
RMSE: 145914.2066
RMSLE: 0.2087
MAPE: 18.9599
--------
Model: ARIMA
RMSE: 77859.477
RMSLE: 0.1069
MAPE: 8.2354
--------
Model: Linear
RMSE: 81054.1673
RMSLE: 0.1107
MAPE: 7.7181
--------
Model: Random forest
RMSE: 68428.7463
RMSLE: 0.0937
MAPE: 6.6161
--------</code></pre>
</div>
</div>
<p>Remember that these are hybrid predictions: Each prediction is the combined result of the linear regression time decomposition model, and the respective lags &amp; covariates models.</p>
<ul>
<li><p>As a refresher, model 1’s standalone performance scores on 2017 data:</p>
<pre><code>RMSE: 75003.7023
RMSLE: 0.1061
MAPE: 8.1491</code></pre></li>
<li><p>Combining model 1 with a baseline model doesn’t increase prediction errors all that much. This is because our data had strong time effects, so getting model 1 right did most of the job. The residuals (decomposed sales) are small in comparison to the model 1 predictions, so adding the predictions from a naive model 2 don’t impact the final predictions too badly.</p></li>
<li><p>Combining model 1 with an ARIMA model increases our errors slightly. However, the performance is still fairly close to the linear and random forest models, especially considering ARIMA didn’t make use of any covariate series.</p></li>
<li><p>Combining model 1 with a second linear model increases our RMSE and RMSLE a bit, but also reduces our MAPE.</p>
<ul>
<li><p>This is likely because MAPE is a measure of relative error, while RMSE and RMSLE are measures of absolute error. For example, an absolute error of 2 translates to 2% MAPE if the actual value is 100, but it translates to 0.2% MAPE if the actual value is 1000. In both cases, the absolute error is the same, but we may argue it’s more “costly” for the former case.</p></li>
<li><p>This likely means that the model 1 + linear hybrid makes larger absolute errors but for more for larger values, while Model 1 makes smaller absolute errors but for more for smaller values. Which case is better is subjective.</p></li>
<li><p>In either case RMSLE could be preferred as it penalizes underpredictions more, and meeting demand can be considered our primary goal.</p></li>
</ul></li>
<li><p>Combining model 1 with the random forest model decreases all error metrics considerably, and it appears to be the winning choice.</p></li>
</ul>
<p>Let’s see the predictions plotted against the actual values, and compare them with model 1 plots.</p>
<div class="cell" data-execution_count="82">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-83-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The performance of the 3 hybrids are similar overall, and it’s hard to see big differences from the plots.</p>
<ul>
<li><p>The random forest did a better job of adjusting to some peaks and troughs, likely because it is able to select features and find interactions between predictors.</p></li>
<li><p>Still, certain large peaks are partially unaccounted for, especially the sharp recovery after January 1st, and the peaks at the start of April and May 2017. These may be due to factors not documented in our dataset. Or they may be related to commemorations for the earthquake in April 2016.</p></li>
</ul>
</section>
<section id="backtesting-historical-forecasts" class="level3">
<h3 class="anchored" data-anchor-id="backtesting-historical-forecasts">Backtesting / Historical forecasts</h3>
<p>We can retrieve the historical forecasts for model 2 as we did for model 1, and add them to model 1’s historical forecasts to retrieve historical forecasts of the hybrid model.</p>
<ul>
<li><p>Keep in mind we performed time decomposition by fitting model 1 on 2013-2016 and retrieving the fitted residuals for 2013-2016.</p></li>
<li><p>This will bias the historical forecasts for 2013-2016, so they shouldn’t be interpreted as reliable out-of-sample validation.</p></li>
<li><p>2017 does not suffer from this issue, as 2017 time decomposed sales were predicted out-of-sample.</p></li>
<li><p>As before, we’ll start by feeding the full year of 2013 as our initial training data, and expand our training window by 1 day in each iteration.</p></li>
</ul>
<div class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Retrieve historical forecasts &amp; residuals for linear + random forest</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit scaler on 2013</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>scaler.fit(ts_lagscovars[:<span class="dv">365</span>])</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict historical forecasts for 2014-2017</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>pred_hist2 <span class="op">=</span> model_forest.historical_forecasts(</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>  trafo_log(ts_decomp), </span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>  future_covariates <span class="op">=</span> scaler.transform(ts_lagscovars), start <span class="op">=</span> <span class="dv">365</span>, stride <span class="op">=</span> <span class="dv">1</span>,</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>  verbose <span class="op">=</span> <span class="va">True</span>) <span class="op">+</span> ts_preds1[<span class="dv">365</span>:]</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Retrieve residuals for 2014-2017</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>res_hist2 <span class="op">=</span> trafo_log(ts_sales[<span class="dv">365</span>:]) <span class="op">-</span> pred_hist2</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Score historical forecasts for linear + random_forest</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>perf_scores(trafo_log(ts_sales[<span class="dv">365</span>:]), pred_hist2, model<span class="op">=</span><span class="st">"Linear + random forest"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"f5d812ca71054a62ab588e46ec8dee13","version_major":2,"version_minor":0}
</script>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: Linear + random forest
RMSE: 60491.8832
RMSLE: 0.0922
MAPE: 6.292
--------</code></pre>
</div>
</div>
<p>With model 1, the overall historical forecasts performed considerably worse than the 2017 predictions. With the hybrid, the historical forecasts seem to have performed slightly better than the 2017 predictions. Again, this is partly misleading due to the way we performed time decomposition, but the improvements from accounting for cyclical effects in 2014-2015 are likely a factor too.</p>
<div class="cell" data-execution_count="84">
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-85-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As we see from the historical forecasts plot, the cyclical fluctuations in 2014 and H1 2015, which were mostly unaccounted for in model 1, are matched nicely with the hybrid model. The peaks and troughs in the rest of the data are also matched better.</p>
</section>
<section id="residuals-diagnosis-stationarity-1" class="level3">
<h3 class="anchored" data-anchor-id="residuals-diagnosis-stationarity-1">Residuals diagnosis &amp; stationarity</h3>
<p>We can diagnose the residuals of the hybrid model and test their stationarity.</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Residuals diagnosis</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plot_residuals_analysis(res_hist2)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="co"># PACF plot</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plot_pacf(res_hist2, max_lag<span class="op">=</span><span class="dv">56</span>)</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.title(<span class="st">"Partial autocorrelation plot, hybrid model innovation residuals"</span>)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xlabel(<span class="st">"Lags"</span>)</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.ylabel(<span class="st">"PACF"</span>)</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">56</span>, <span class="dv">10</span>))</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.xticks(np.arange(<span class="dv">0</span>, <span class="dv">56</span>, <span class="dv">1</span>), minor<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.grid(which<span class="op">=</span><span class="st">'minor'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> plt.grid(which<span class="op">=</span><span class="st">'major'</span>, alpha<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>plt.close(<span class="st">"all"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-86-output-1.png" class="img-fluid"></p>
</div>
<div class="cell-output cell-output-display">
<p><img src="ReportPart1_files/figure-html/cell-86-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Overall, the residuals seem much closer to stationary.</p>
<ul>
<li><p>There are a few particularly large residuals, especially in 2014-2015, and at year starts.</p></li>
<li><p>The distribution of residuals is more centered around 0, with smaller extreme values. This time, the extreme values are well-balanced between positive and negative. It’s still possible to say the models underpredict a bit more than they overpredict. The opposite would be more preferable.</p></li>
<li><p>The ACF and PACF plots display almost no significant autocorrelation, except for a weak autocorrelation with lag 1.</p></li>
</ul>
<div class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stationarity tests on hybrid model residuals</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"KPSS test p-value: "</span> <span class="op">+</span> </span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  stationarity_test_kpss(res_hist2)[<span class="dv">1</span>].astype(<span class="bu">str</span>)</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null rejected = data is non-stationary</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ADF test p-value: "</span> <span class="op">+</span> </span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">str</span>(stationarity_test_adf(res_hist2)[<span class="dv">1</span>])</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>) <span class="co"># Null rejected = data is stationary around a constant</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KPSS test p-value: 0.04035267060926849
ADF test p-value: 0.0</code></pre>
</div>
</div>
<p>The stationarity tests are still conflicting:</p>
<ul>
<li><p>The p-value for the KPSS test is smaller than 0.05, leading us to reject the null hypothesis of stationarity around a constant. However, the p-value is much larger than the KPSS test on model 1 residuals, so we are fairly close to stationarity.</p></li>
<li><p>The p-value for the ADF test is 0, rejecting the null hypothesis of the presence of an unit root. This implies the data is stationary around a constant.</p></li>
</ul>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In part 1 of this analysis, we were able to predict national daily sales, aggregated across all categories and stores, pretty well.</p>
<ul>
<li><p>In the end, a hybrid model combining linear regression for the time effects, and random forest regression for the remainder, gave us the best results.</p></li>
<li><p>However, the second model’s relative improvement was fairly small, as the first model already performed very well.</p></li>
<li><p>This means the time &amp; seasonality effects in our data were much stronger than any “unexpected” cyclicality, which is what we’d intuitively expect for supermarket sales.</p></li>
<li><p>Still, there was considerable cyclicality in 2014 and H2 2015, which showed up as relatively large values in the residuals of model 1. Applying autoregression in model 2 helped us adjust for these.</p></li>
<li><p>Autoregression is more “reactive” than predictive: It likely won’t predict a first sudden fluctuation before it happens, but that fluctuation will enter the model as a predictor in the next period, and allow the model to adjust for the following periods.</p></li>
</ul>
<p>In part 2, we will attempt to make a competition submission, predicting the daily sales for every store &amp; every category combination. That makes 33 categories across 54 stores, a total of 1782 series to generate a prediction for.</p>
<ul>
<li><p>In part 1, with only one series to predict, we were able to perform exploratory analysis and carefully tailor our models, especially for time decomposition. It’s also generally easier to predict more aggregated series, as they are less noisy: The national sales likely fluctuate much less compared to sales in one store or category.</p></li>
<li><p>In part 2, we will have to come up with a strategy that will simplify our work, while still yielding good predictions. The 33 product categories likely have very different seasonality patterns. We’ll likely rely on more “automatic” models that are able to derive time effects &amp; seasonality, and ideally model them along with autocorrelation and any covariate effects in one go instead of using hybrids or tailored feature sets.</p></li>
<li><p>We’ll also explore the topic of <strong>hierarchical reconciliation</strong>: Making sure our predictions are coherent within the levels of hierarchy. There are several methods to reconcile predictions in a hierarchy, and it can even improve prediction accuracy.</p></li>
</ul>
<p>Any comment or suggestion is welcome.</p>
</section>

</main>
<!-- /main column -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"01e944e050234bb0a686a36adf8263e8":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_6a98f774097442878f42653ba69f60ce","placeholder":"​","style":"IPY_MODEL_790fd34eaf604cfab2637258cb20b061","tabbable":null,"tooltip":null,"value":" 1323/1323 [00:08&lt;00:00, 146.63it/s]"}},"140aff669faf4315b1728888b4a9cd30":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"1534779155474bd882fa04c6ec595cf7":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"2796c7dddd654f97a5fd57fcc10ff379":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_c3a822f507a94f37ac02bc49b8c938e1","placeholder":"​","style":"IPY_MODEL_1534779155474bd882fa04c6ec595cf7","tabbable":null,"tooltip":null,"value":"100%"}},"2e6828f8b0964b7d93cae4d0447c3007":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"40755d90840543349f8af60d6cdd3767":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"46dc2e7100bc462694ded2a0a00b0f89":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"54853f8b72244e97a5cdfa12520a1568":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"ProgressView","bar_style":"success","description":"","description_allow_html":false,"layout":"IPY_MODEL_46dc2e7100bc462694ded2a0a00b0f89","max":1323,"min":0,"orientation":"horizontal","style":"IPY_MODEL_140aff669faf4315b1728888b4a9cd30","tabbable":null,"tooltip":null,"value":1323}},"631ea1cb65e04506b14d693eebf09e3c":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"6a98f774097442878f42653ba69f60ce":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"790fd34eaf604cfab2637258cb20b061":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"7d9e0458278844c295f99cee40b4ade9":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_d50fab27d16a4cb3ac7ac809e274aff6","placeholder":"​","style":"IPY_MODEL_fdc325cb394c484fa317125e1608930d","tabbable":null,"tooltip":null,"value":" 1323/1323 [02:30&lt;00:00,  7.20it/s]"}},"ab29b09a20464e1abc1532625765116a":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"ProgressView","bar_style":"success","description":"","description_allow_html":false,"layout":"IPY_MODEL_b649c22cbdc0401a8ee30d72bae18d99","max":1323,"min":0,"orientation":"horizontal","style":"IPY_MODEL_f666bd093dfe4617910ac3c642c7c1d1","tabbable":null,"tooltip":null,"value":1323}},"ac11043c709d49fbbcd18c7bba9f1d45":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_c8c6350347cc4fa1abcc2d73679829e7","placeholder":"​","style":"IPY_MODEL_2e6828f8b0964b7d93cae4d0447c3007","tabbable":null,"tooltip":null,"value":"100%"}},"b649c22cbdc0401a8ee30d72bae18d99":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"c3a822f507a94f37ac02bc49b8c938e1":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"c8c6350347cc4fa1abcc2d73679829e7":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"d50fab27d16a4cb3ac7ac809e274aff6":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"f566456c9aa94658af47f81bb9b38db5":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_ac11043c709d49fbbcd18c7bba9f1d45","IPY_MODEL_ab29b09a20464e1abc1532625765116a","IPY_MODEL_01e944e050234bb0a686a36adf8263e8"],"layout":"IPY_MODEL_40755d90840543349f8af60d6cdd3767","tabbable":null,"tooltip":null}},"f5d812ca71054a62ab588e46ec8dee13":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_2796c7dddd654f97a5fd57fcc10ff379","IPY_MODEL_54853f8b72244e97a5cdfa12520a1568","IPY_MODEL_7d9e0458278844c295f99cee40b4ade9"],"layout":"IPY_MODEL_631ea1cb65e04506b14d693eebf09e3c","tabbable":null,"tooltip":null}},"f666bd093dfe4617910ac3c642c7c1d1":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"fdc325cb394c484fa317125e1608930d":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>